¦Ifinal_url¡DtypeLhttp_headers¢DtypeEvalue†¢Ak¢DtypeEvalueNContent-LengthAv¢DtypeEvalueD5852¢Ak¢DtypeEvalueMAccept-RangesAv¢DtypeEvalueEbytes¢Ak¢DtypeEvalueFServerAv¢DtypeEvalueX4Apache/2.4.6 (CentOS) OpenSSL/1.0.2k-fips SVN/1.7.14¢Ak¢DtypeEvalueMLast-ModifiedAv¢DtypeEvalueXTue, 20 Aug 2013 23:13:20 GMT¢Ak¢DtypeEvalueDETagAv¢DtypeEvalueT"16dc-4e46933e22400"¢Ak¢DtypeEvalueDDateAv¢DtypeEvalueXFri, 08 Feb 2019 15:33:52 GMTKraw_content¢DtypeEvalueYÜ# myrange.py
#
# ICS 33 Summer 2013
# Code Example
#
# The MyRange class duplicates some of the functionality of the built-in
# Python 'range' class.  While we wouldn't normally rewrite things in the
# standard library (unless we needed them to work differently), it can be
# a useful learning exercise, because it allows you to understand the
# underlying details of a problem that you already understand.  You already
# know how to work with ranges; this class lets you explore how they work
# internally.


class MyRange:
    # There are three ways to construct a range:
    #
    # * MyRange(5), in which case 5 is considered to be the stop value,
    #   0 is the start, and the step is 1.
    # * MyRange(5, 10), in which case 5 is the start, 10 is the stop,
    #   and the step is 1.
    # * MyRange(5, 10, 2), in which case 5 is the start, 10 is the stop,
    #   and the step is 2.
    #
    # Those three possibilities are captured here by using "default
    # arguments" in the __init__ method.  Because the "stop" and "step"
    # parameters have default values specified, it's possible to call
    # __init__ without specifiying step, without specifying stop or step,
    # or by specifying all three.  (Note that you can't specify step without
    # also specifying stop; order is important here.)
    def __init__(self, start, stop = None, step = 1):
        if stop == None:
            # If stop wasn't specified, the caller must have passed only one
            # argument to __init__, so we'll consider the one argument to be
            # the stop value, set start to 0, and step to 1.

            if type(start) != int:
                raise TypeError('stop must be an integer')

            self._start = 0
            self._stop = start
            self._step = step

        else:
            # If stop was specified, start was also specified, so we'll
            # use both of them, and pick up the value of step (which will
            # default to 1 automatically if not specified).
            
            if type(start) != int or type(stop) != int:
                raise TypeError('start and stop must both be integers')

            self._start = start
            self._stop = stop
            self._step = step


    # The canonical representation of a MyRange, as is typical (when possible)
    # in Python, returns legal Python code for creating an identical MyRange
    # object.  There are a few ways to create them -- you can specify only
    # a stop value; or you can specify a start and a stop; or you can specify
    # a start, stop, and step -- and those possibilities are covered here.
    def __repr__(self):
        if self._start == 0 and self._step == 1:
            return 'MyRange({})'.format(self._start)
        elif self._step == 1:
            return 'MyRange({}, {})'.format(self._start, self._stop)
        else:
            return 'MyRange({}, {}, {})'.format(self._start, self._stop, self._step)


    # When we ask a MyRange for an iterator, we'll construct a new one.
    # It's important to understand that iterators are one-time-use objects:
    # you use them to iterate through an object, then you're done with them;
    # if you need to iterate again, you can always ask for another iterator.
    #
    # In our case, we construct an object of our own class _MyRangeIterator.
    # We need our own iterator class because the details of iterating a
    # MyRange are specific to our MyRange class, so there needs to be an
    # object that's aware of those internals; _MyRangeIterator is that class.
    def __iter__(self):
        return _MyRangeIterator(self._start, self._stop, self._step)


    # When we ask a MyRange for a reverse iterator, it's similar to asking
    # it for a regular "forward" iterator, but we adjust the start and stop
    # values and negate the step value, so that we'll visit the values in the
    # reverse of the order we normally would.
    def __reversed__(self):
        revstart = self._stop - self._step
        revstop = self._start - self._step
        revstep = -self._step
        return _MyRangeIterator(revstart, revstop, revstep)



# A _MyRangeIterator is an object that knows only how to iterate a MyRange
# object and nothing else.  It is an iterator, meaning that it needs a
# __next__ and an __iter__ method (because these are required by the
# iterator protocol).  It is marked private because these are internal
# details; code using an iterator does not need to know (and, in general,
# shouldn't depend) on knowing specifically what kind of iterator it's
# using.  It should just know that it has *some* kind of iterator.
#
# The general approach used here is to store the stop and step values,
# since we'll need to know how large of a step to take each time __next__
# is called and we'll need to know when to raise StopIteration.  We'll
# also keep track of the "next value" that we'll return from this iterator,
# a value that will be updated every time __next__ is called.

class _MyRangeIterator:
    def __init__(self, start, stop, step):
        self._stop = stop
        self._step = step
        self._next_value = self._start


    def __next__(self):
        if self._past_end():
            raise StopIteration()
        else:
            result = self._next_value
            self._next_value += self._step
            return result


    def __iter__(self):
        return self


    # _past_end returns True if we're "past the end" (i.e., there are no
    # more values to return from this iterator) or False if not.
    def _past_end(self):
        return (self._step > 0 and self._next_value >= self._stop) \
                or (self._step < 0 and self._next_value <= self._stop)
Mis_redirected¢DtypeEvalueôIhttp_code¢DtypeEvalueÈQdownload_complete¢DtypeEvalueõ