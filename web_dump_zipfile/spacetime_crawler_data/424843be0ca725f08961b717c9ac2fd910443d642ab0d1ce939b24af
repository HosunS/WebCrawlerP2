¦Ifinal_url¡DtypeLhttp_headers¢DtypeEvalue†¢Ak¢DtypeEvalueNContent-LengthAv¢DtypeEvalueD2404¢Ak¢DtypeEvalueMAccept-RangesAv¢DtypeEvalueEbytes¢Ak¢DtypeEvalueFServerAv¢DtypeEvalueX4Apache/2.4.6 (CentOS) OpenSSL/1.0.2k-fips SVN/1.7.14¢Ak¢DtypeEvalueMLast-ModifiedAv¢DtypeEvalueXWed, 31 Oct 2018 17:32:24 GMT¢Ak¢DtypeEvalueDETagAv¢DtypeEvalueS"964-57989af74d42f"¢Ak¢DtypeEvalueDDateAv¢DtypeEvalueXMon, 04 Feb 2019 02:43:13 GMTKraw_content¢DtypeEvalueY	dy <- c(62,60,63,59,0,0,0,0,63,67,71,64,65,66,0,0,68,66,71,67,68,68,0,0,
    56,62,60,61,63,64,63,59)
dim(y) <- c(8,4)
n<-24 
nj<-c(4,6,6,8)
ybar<-c(61,66,68,61)
#
# log marg post density (in terms of parm=(mu,log sigma, log tau))
#
lmarg <- function (parm){
  mu <- parm[1]
  sigma <- exp(parm[2])
  tau <- exp(parm[3])
  theta <- ((1/tau^2)*mu + (nj/sigma^2)*ybar)/((1/tau^2) + (nj/sigma^2))
  Vtheta <- 1/((1/tau^2) + (nj/sigma^2))
  output <- log(tau) + sum (log(dnorm (theta, mu, tau)))
  for (j in 1:length(nj))
    output <- output + sum(log(dnorm(y[1:nj[j],j], theta[j], sigma)))
  output <- output + .5*sum(log(Vtheta))
  output }
#
# numerical first derivatives
numder1 <- function(x,fun,step=.0001) {
  n <- length(x)
  der1 <- rep(0, n)
  for (i in (1:n)) {
     y <- x
     del <- ifelse(x[i] == 0, step, step*x[i])
     y[i] <- x[i] + del
     l2 <- fun(y)
     y[i] <- x[i] - del
     l1 <- fun(y)
     der1[i] <- (l2 - l1)/(2*del) }
  der1 }
#
# numerical second derivatives
numder2 <- function(x,fun, step=.0001) {
  n <- length(x)
  der2 <- matrix(0, n, n)
  for (i in (1:n)) {
     del1 <- ifelse(x[i] == 0, step, step*x[i])
     for (j in (1:n)) {
        y <- x
        del2 <- ifelse(x[j] == 0, step, step*x[j])
        y[i] <- y[i] + del1
        y[j] <- y[j] + del2
        l1 <- fun(y)
        y[j] <- y[j] - 2*del2
        l2 <- fun(y)
        y[i] <- y[i] - 2*del1
        l3 <- fun(y)
        y[j] <- y[j] + 2*del2
        l4 <- fun(y)
        der2[i,j] <- (l2 + l4 - l1 - l3)/(4*del1*del2)
        der2[j,i] <- der2[i,j] } } 
     der2 } 
#
# numerical newton's method algorithm
numnr <- function(x,fun,nloop=5) {
  y <- x
  for (i in (1:nloop)) {
     d1 <- numder1(y,fun)
     d2 <- numder2(y,fun)
     y <- solve(d2)%*%d1 + y  }
  z <- list(ans = y, der1 = d1, vcov = solve(d2))
  z }
#
# set initial values
params <- c(64, log(2.5), log(3))
a <- numnr(params, lmarg)
#
# output
#a$ans
#           [,1]
#[1,] 64.0123063 = mu
#[2,]  0.8593093 = log(sigma) -->  sigma = 2.362
#[3,]  1.2444319 = log(tau)   -->  tau = 3.471
#
#a$der1
#[1] -5.550048e-13 -8.268766e-11 -8.564664e-11 (basically zero)
#
#a$vcov
#             [,1]         [,2]         [,3]
#[1,]  3.257666426  0.000540608 -0.004067419
#[2,]  0.000540608  0.024788554 -0.001204074
#[3,] -0.004067419 -0.001204074  0.194358806

Mis_redirected¢DtypeEvalueôIhttp_code¢DtypeEvalueÈQdownload_complete¢DtypeEvalueõ