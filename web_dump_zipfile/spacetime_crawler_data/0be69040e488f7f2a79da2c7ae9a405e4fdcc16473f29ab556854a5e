¦Ifinal_url¢DtypeEvaluex>https://www.ics.uci.edu/~thornton/ics32/Notes/TypeAnnotations/Lhttp_headers¢DtypeEvalue‡¢Ak¢DtypeEvalueNContent-LengthAv¢DtypeEvalueE11045¢Ak¢DtypeEvalueMAccept-RangesAv¢DtypeEvalueEbytes¢Ak¢DtypeEvalueFServerAv¢DtypeEvalueX4Apache/2.4.6 (CentOS) OpenSSL/1.0.2k-fips SVN/1.7.14¢Ak¢DtypeEvalueMLast-ModifiedAv¢DtypeEvalueXMon, 07 Jan 2019 06:11:49 GMT¢Ak¢DtypeEvalueDETagAv¢DtypeEvalueT"2b25-57ed81aaaf340"¢Ak¢DtypeEvalueDDateAv¢DtypeEvalueXThu, 07 Feb 2019 04:16:54 GMT¢Ak¢DtypeEvalueLContent-TypeAv¢DtypeEvalueXtext/html; charset=UTF-8Kraw_content¢DtypeEvalueY+%<?xml version="1.0" encoding="iso-8859-1"?>
<!DOCTYPE html PUBLIC
 "-//W3C//DTD XHTML 1.1//EN"
 "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">

<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en">

<head>
<meta http-equiv="content-type" content="text/html; charset=iso-8859-1" />
<link rel="stylesheet" href="../../course.css" type="text/css" />

<title>ICS 32 Winter 2019, Python Background Notes: Type Annotations</title>

</head>

<body>

<div class="navbar">

<p>
ICS 32 Winter 2019 |
<a href="../../index.html">News</a> |
<a href="../../CourseReference.html">Course Reference</a> |
<a href="../../Schedule.html">Schedule</a> |
<a href="../../ProjectGuide">Project Guide</a> |
<a href="../../Notes">Notes and Examples</a> |
<a href="http://www.ics.uci.edu/~thornton/">About Alex</a>
</p>

<hr />

</div>

<div class="header">

<p>ICS 32 Winter 2019<br />
   Python Background Notes: Type Annotations</p>

</div>

<div class="section">

<hr />

<p class="title">Statically- and dynamically-typed languages</p>

<p>Depending on what programming languages you've learned in the past, you might feel right at home in Python, but you might also feel a bit like a fish out of water.  There are a number of ways that different programming languages differ from one another.  One of the key distinctions between programming languages is in their handling of types.</p>

<p>You can think of all programming languages as existing on a spectrum, with respect to how and when they handle types, with the two ends of that spectrum being these.</p>

<ul>
  <li><i>Statically-typed languages</i> are those whose types are checked before the program runs.  A program cannot run with type errors, because those pre-execution checks will fail.</li>
  <li><i>Dynamically-typed languages</i> are those whose types are checked during a program's execution.  For the most part, structurally correct programs can run, even if they have type errors; those type errors will manifest themselves as run-time errors while the program runs.</li>
</ul>

<p>Note that the reason I say there is a spectrum here is because there exists middle ground &mdash; languages like C++ and Java, for example, mostly check types before execution, but also allow some of those checks (in the form of <i>casts</i>) to be deferred until the program runs.  The usual tradeoff if you want types to be checked statically (i.e., before the program runs) is that you'll need to say something explicitly about types in your program; Java and C++, for example, require a type to be declared for every variable, and then will verify that what you do with those variables matches your stated intent.</p>

<p>As we've seen already, Python is firmly on the dynamic end of the spectrum.  For the most part, if you follow Python's structural rules &mdash; the <i>syntax</i> of the language &mdash; you'll have a Python script that can be executed, though that script may fail during execution.  It's not necessary to specify the types of variables, functions' parameters or results, and so on, because there's no explicit need; the types won't be checked until the program is executing, by which time those types will be clear (e.g., a variable's "type" at any given time would simply be the type of object currently stored in that variable).</p>

<p>However, that's not the end of the story of types in Python.  When we write programs, we don't just write them for computers to execute; we write them for people to read and understand, as well.  So, to the extent that we can communicate a fuller understanding of the intent of the code we write without negatively affecting how the program runs, everyone is better off.  Python offers that ability: Even though types aren't checked until run time, we can nonetheless describe them in a fairly unambiguous way using Python syntax.</p>

</div>

<div class="section">

<hr />

<p class="title">Type annotations</p>

<p>Recent versions of Python have added a syntax for <i>type annotations</i>, which allow you to specify information about the types that will be processed by the code you're writing.  Type annotations are more open-ended than you might imagine at first.  In fact, they mainly serve as a way to specify this information for people; when programs run, the type annotations are, for the most part, ignored.  (There is additionally a longer-term goal of introducing tools that can be used to check types in a Python program before running it, though this is still a developing area of the Python community and lies beyond the scope of our work this quarter.)</p>

<p>A type annotation can actually be just about any arbitrary Python expression you can write; the only requirement is that it be a syntactically-legal expression.  Of course, the true goal is to communicate type information in a way that people can read it and understand it.  To the extent that you can name the types explicitly, your annotations will be more readable; as we'll see, there are times when we'll need to use more open-ended techniques.</p>

<p class="subtitle">Annotating functions</p>

<p>When you write a function, you can add annotations to its parameters and its return value.  It's not necessary to add annotations to all parameters &mdash; you can pick and choose &mdash; and it's also not necessary to annotate the return type.  In general, though, you'll want to add all of them.</p>

<p>A type annotation is written on a parameter by following its name with a colon and then an expression describing its type.  The return type of a function is described by following the parameter list with an <i>arrow</i> &mdash; technically, a dash followed by a greater-than sign &mdash; after which you would write an expression describing its type.</p>

<p>As an example, suppose we were writing a function <b>len_at_least</b> that takes two parameters, a string and an integer, and returns <b>True</b> if the length of the string is at least the given integer value.  So, for example, <b>len_at_least('Boo', 2)</b> would return <b>True</b> (because the length of <b>'Boo'</b> is 3, which is greater than 2), while <b>len_at_least('Alex', 10)</b> would return <b>False</b> (because the length of <b>'Alex'</b> is 4, which is less than 10).  We might write the function, complete with type annotations and a docstring, this way:</p>

<blockquote><pre>
def len_at_least(s: str, min_length: int) -&gt; bool:
    'Returns True if s has a length at least the given minimum'
    return len(s) &gt;= min_length
</pre></blockquote>

<p>When you write functions in this course, you're going to want to include both the type annotations and the docstring.  If you can't succinctly describe what the purpose of your own function is &mdash; what it does, what its inputs are, what its output is, how it might fail &mdash; you're probably not ready to write it.  To solidify your thinking, we'll require the type annotations and docstrings.</p>

<p class="subtitle">Annotating variables</p>

<p>The most recent release of Python, version 3.6, added the ability to annotate the types of variables, as well.  There are a couple of ways to do it.  One is to introduce the type annotation separately from giving it a value.</p>

<blockquote><pre>
age: int
age = 42
</pre></blockquote>

<p>Perhaps surprisingly, note that the variable <b>age</b> doesn't yet have a value until after it's first assigned, even if a type annotation precedes that assignment; however, it will be created in the scope where you annotated it, even if it's never assigned.  Otherwise, the annotation doesn't actually <i>do</i> anything, other than communicate your intent to a human reader of your program.</p>

<p>You can also combine the type annotation into an assignment statement, if you prefer, which is shorter to write, if perhaps a little bit confusing when names get longer.</p>

<blockquote><pre>
age: int = 42
</pre></blockquote>

<p>We are not requiring you to annotate every variable in this course.  Variables should generally have a limited scope; generally, they'll be local a single function.  Since your functions will be short and simple &mdash; with each one having a single responsibility &mdash; there's less value in variable annotations, from a readability perspective.  However, you should at least be considering what types of values you intend to store in your variables, and if type annotations on variables help you to clarify that, you should certainly feel free to use them.</p>

<p class="subtitle">What annotations are allowed to say</p>

<p>There is technically no restriction on what you can say in a type annotation; any syntactically-legal Python expression will do.  However, a rule of thumb for us is to use these rules.</p>

<ul>
  <li>If the type has a single name, such as <b>int</b> or <b>str</b>, we'll prefer to use that.</li>
  <li>If there are multiple types that would be considered okay, such as an annotation specifying that something might be an integer or a float, we can use the Python <b>or</b> operator.  In this case, we might write <b>int or float</b>.</li>
  <li>We can use parentheses and commas to specify a tuple type, so that we can specify the types of each of the tuple's elements.  For example, a type annotation for a tuple containing an integer and a string would be written as <b>(int, str)</b>.</li>
  <li>We can use brackets around a type to specify a list.  So, for example, a list that should contain integers could be annotated as <b>[int]</b>.  A list containng a combination of integers or floats could be annotated as <b>[int or float]</b>.</li>
  <li>When all else fails, we can also simply use a string literal to describe our types.  You won't want to fall back on this every time &mdash; it's better to use something more directly syntactic, if you can &mdash; but it's a tool worth having in our toolbox.</li>
</ul>

<p>Putting these ideas together, here is a function that takes a list of integers or floats and computes their sum, complete with type annotations and a docstring.</p>

<blockquote><pre>
def sum_numbers(nums: [int or float]) -> int or float:
    'Computes the sum of the numbers in the given list'

    total = 0

    for num in nums:
        total += num

    return total
</pre></blockquote>

</div>

<div class="section">

<hr />

<p class="title">Remember: Annotations are not checked</p>

<p>A really important thing to keep in mind, especially if you've written programs in languages that have static type checking, is that the type annotations you'll write in Python will not be checked.  You'll be able to write annotations that are incomplete, or even completely nonsensical, and the program may still run just fine.  Still, you'll want to be sure that you're keeping your annotations up to date, because they're a way that you can be sure that your understanding of your own program is similarly up to date.</p>

</div>

</body>
</html>
Mis_redirected¢DtypeEvalueõIhttp_code¢DtypeEvalueÈQdownload_complete¢DtypeEvalueõ