¦Ifinal_url¡DtypeLhttp_headers¢DtypeEvalue‡¢Ak¢DtypeEvalueNContent-LengthAv¢DtypeEvalueD1712¢Ak¢DtypeEvalueMAccept-RangesAv¢DtypeEvalueEbytes¢Ak¢DtypeEvalueFServerAv¢DtypeEvalueX„Apache/2.4.6 (CentOS) OpenSSL/1.0.2k-fips SVN/1.7.14 mod_wsgi/3.4 Python/2.7.5 Phusion_Passenger/4.0.53 mod_perl/2.0.10 Perl/v5.16.3¢Ak¢DtypeEvalueMLast-ModifiedAv¢DtypeEvalueXWed, 17 Apr 2013 01:54:20 GMT¢Ak¢DtypeEvalueDETagAv¢DtypeEvalueS"6b0-4da84c3a8cb00"¢Ak¢DtypeEvalueDDateAv¢DtypeEvalueXSun, 10 Feb 2019 11:19:59 GMT¢Ak¢DtypeEvalueLContent-TypeAv¢DtypeEvalueXtext/plain; charset=UTF-8Kraw_content¢DtypeEvalueY°/*
    $Id$

    Copyright (C) 2007 by The Regents of the University of California

    Redistribution of this file is permitted under the terms of the
    GNU Public License (GPL).

    Date: 01/14/2006
    Author: Rares Vernica <rvernica@ics.uci.edu>
*/

#include "lexic.h"

class LexicCmp
{
private:
  const vector<string> *data;
public:
  LexicCmp(const vector<string> *d): data(d) {}
  bool operator()(unsigned a, unsigned b) const { return (*data)[a] < (*data)[b]; }
};  

Lexic::Lexic(const vector<string> *d, const unsigned clusterNo, 
           const SampleType sampleType, const unsigned samplePer,
           const unsigned queueSize, const unsigned uniqueNo): 
  Clusters(d, clusterNo, sampleType, samplePer, queueSize, uniqueNo)
{  
  for (unsigned i = 0; i < clusterNo; i++)
    clusters->push_back(Cluster());
}

void Lexic::buildClusters() 
{
  vector<unsigned> dId(data->size());
  for (unsigned i = 0; i < data->size(); i++) dId[i] = i;

  sort(dId.begin(), dId.end(), LexicCmp(data));

  const unsigned n = static_cast<unsigned>(data->size());
  const unsigned nclust = n/clusterNo;
  for (unsigned i = 0; i < clusterNo; i++) {
    const unsigned start = i*nclust;
    const unsigned end = (i == clusterNo? n:(i + 1) * nclust);
    const unsigned p = start + (end - start)/2;
    (*clusters)[i].setPivot(dId[p]);
    SimType radius = (*clusters)[i].getRadius();
    for (unsigned j = start; j < end; j++) {
      (*clusters)[i].insert(dId[j]);
      radius = max(radius, SimDist((*data)[dId[p]], (*data)[dId[j]]));
    }
    (*clusters)[i].setRadius(radius);
  }
}

ostream& Lexic::info(ostream& out)
{
  Clusters::info(out);
  out << "Cluster method\tLexic" << endl;
  return out << endl;
}
Mis_redirected¢DtypeEvalueôIhttp_code¢DtypeEvalueÈQdownload_complete¢DtypeEvalueõ