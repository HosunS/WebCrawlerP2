¦Ifinal_url¢DtypeEvaluex>https://www.ics.uci.edu/~thornton/ics46/Notes/NaryBinaryTrees/Lhttp_headers¢DtypeEvalue‡¢Ak¢DtypeEvalueNContent-LengthAv¢DtypeEvalueD6960¢Ak¢DtypeEvalueMAccept-RangesAv¢DtypeEvalueEbytes¢Ak¢DtypeEvalueFServerAv¢DtypeEvalueX4Apache/2.4.6 (CentOS) OpenSSL/1.0.2k-fips SVN/1.7.14¢Ak¢DtypeEvalueMLast-ModifiedAv¢DtypeEvalueXMon, 30 Apr 2018 01:35:27 GMT¢Ak¢DtypeEvalueDETagAv¢DtypeEvalueT"1b30-56b06de4b35c0"¢Ak¢DtypeEvalueDDateAv¢DtypeEvalueXTue, 05 Feb 2019 22:46:11 GMT¢Ak¢DtypeEvalueLContent-TypeAv¢DtypeEvalueXtext/html; charset=UTF-8Kraw_content¢DtypeEvalueY0<?xml version="1.0" encoding="iso-8859-1"?>
<!DOCTYPE html PUBLIC
 "-//W3C//DTD XHTML 1.1//EN"
 "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">

<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en">

<head>
<meta http-equiv="content-type" content="text/html; charset=iso-8859-1" />
<link rel="stylesheet" href="../../course.css" type="text/css" />

<title>ICS 46 Spring 2018, Notes and Examples: N-ary and Binary Trees</title>

</head>

<body>

<div class="navbar">

<p>
ICS 46 Spring 2018 |
<a href="../../index.html">News</a> |
<a href="../../CourseReference.html">Course Reference</a> |
<a href="../../Schedule.html">Schedule</a> |
<a href="../../ProjectGuide">Project Guide</a> |
<a href="../../Notes">Notes and Examples</a> |
<a href="http://www.ics.uci.edu/~thornton/">About Alex</a>
</p>

<hr />

</div>

<div class="header">

<p>ICS 46 Spring 2018<br />
   Notes and Examples: N-ary and Binary Trees</p>

</div>

<div class="section">

<hr />

<p class="title">Restricting the shape of a tree</p>

<p>Previously, we've seen trees as a fairly general data structure, in which any node can have any number of subtrees associated with it.  Sometimes, that generality is exactly what you want, because one use of a tree is in representing data that's genuinely hierachical, and whether nodes have fewer or more subtrees is purely a matter of what data you'd like to represent.  For example, files and directories on a filesystem are (more or less) a hierachy; similarly, if you were writing software that need to represent the organizational structure of a company (i.e., which people report to which other people, a structure that is quite often hierarchical), you might also use a tree to represent it.  The shape of the tree would be constrained only by the data in question &mdash; the files and directories you wanted to store, or the organizational structure you wanted to represent.</p>

<p>However, trees have use in situations where the data is not itself hierachical; we can use the hierachy provided by trees to achieve other goals, such as making certain kinds of searches or rearrangements faster.  To do that, though, we quite often have to restrict the shape of our tree somewhat, by limiting how many children each node can have, or by limiting the relative heights of sibling subtrees.  How we limit the shape depends on why we're limiting it and what we'll gain from it; we'll see several examples of this going forward, beginning with the ones directly below.</p>

</div>

<div class="section">

<hr />

<p class="title">N-ary trees</p>

<p>First, we'll consider trees that restrict their shape by strictly defining how many subtrees each node will have.</p>

<blockquote>
An <i>N-ary tree</i> of order N is either:

<ul>
  <li>empty</li>
  <li>a <i>root node</i>, along with exactly N disjoint <i>subtrees</i>, each of which is an N-ary tree of order N</li>
</ul>
</blockquote>

<p>There are a couple of things to notice about this definition.  First of all, look at how similar it is to the original, general definition of a tree that we saw in the <a href="../GeneralTrees">General Trees</a> notes previously.  The only meaningful difference &mdash; aside from the name of the data structure &mdash; is the restriction that every non-empty tree have exactly the same number of subtrees.  Secondly, you should also take note that, just as before, empty trees are still trees, though they serve a more important purpose in an N-ary tree: Since every node must have exactly N subtrees, the fact that some of them can be empty is the only way you can approximate the idea of some nodes having more (meaningful) subtrees than others.</p>

<p>An N-ary tree is most commonly drawn like the one below, which is an N-ary tree of order 3 &mdash; which you might also call a <i>ternary tree</i>.</p>

<p class="center"><img src="NaryTree.png" alt="N-ary Tree of order 3" /></p>

<p>The circles are the root nodes of each subtree.  These are sometimes called <i>internal nodes</i>, and are the ones where data is generally stored.  The smaller-sized boxes denote empty subtrees, which are sometimes called <i>external nodes</i>; generally, external nodes store nothing, and might be implemented with a null pointer in C++, or with an object that has member functions that return default values when asked questions like "What is your height?" or "What is your value?"</p>

<p>The concept of an N-ary tree is a somewhat abstract one, but one that demonstrates a core idea: Sometimes you're better off if you can restrict how many children each node can have.  That restriction is used to solve different kinds of problems.  For example, as we'll see, we can use N-ary trees of order 2 to organize data so that it can be efficiently searched; we'll see these later as <i>binary search trees</i>.  Meanwhile, N-ary trees of order 4 and 8 are sometimes used to organize spatial information &mdash; where objects reside in areas of two-dimensional or three-dimensional space &mdash; so that it is relatively cheap to determine, for example, which objects are near (or are possibly colliding with) which others; when used this way, they're typically called <i>quadtrees</i> or <i>octrees</i>.</p>

<p>To get our minds wrapped around this concept a little more completely, let's consider one example in more depth.</p>

</div>

<div class="section">

<hr />

<p class="title">Binary trees</p>

<p>When we restrict the number of children of each node to exactly two, we've got what's called a <i>binary tree</i>, which we'll define by layering an additional concept atop the N-ary tree concept we've seen already.</p>

<blockquote>
A <i>binary tree</i> is an N-ary tree of order 2, in which one of the two subtrees of each internal node is the <i>left subtree</i> and the other is the <i>right subtree</i>.
</blockquote>

<p>Notice, then, that we've introduced an explicit notion of <i>ordering</i> here, in that one of the subtrees of each node is considered the "left" and the other is considered the "right."  That's not an arbitrary choice; that will enable us to accomplish some things that would be very difficult if we didn't.</p>

<p>If we were to draw a binary tree, we might do it like this:</p>

<p class="center"><img src="BinaryTree.png" alt="Binary Tree" /></p>

<p>Note, also, that the presence of the external nodes is implied, so we need not actually draw them.  As long as we draw parent/child relationships carefully, so that it's explicit whether each subtree is a left or right subtree, we don't need to draw the external nodes; for simplicity, I'll leave them off of our binary tree diagrams from here on out.  The diagram above could also, then, be drawn this way:</p>

<p class="center"><img src="BinaryTreeWithoutExternalNodes.png" alt="Binary Tree (without external nodes pictured)" /></p>

</div>

</body>
</html>
Mis_redirected¢DtypeEvalueõIhttp_code¢DtypeEvalueÈQdownload_complete¢DtypeEvalueõ