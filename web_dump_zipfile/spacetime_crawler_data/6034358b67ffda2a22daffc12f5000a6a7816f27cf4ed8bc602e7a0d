¦Ifinal_url¢DtypeEvaluex>https://www.ics.uci.edu/~thornton/ics46/Notes/GraphTraversals/Lhttp_headers¢DtypeEvalue‡¢Ak¢DtypeEvalueNContent-LengthAv¢DtypeEvalueE21571¢Ak¢DtypeEvalueMAccept-RangesAv¢DtypeEvalueEbytes¢Ak¢DtypeEvalueFServerAv¢DtypeEvalueX4Apache/2.4.6 (CentOS) OpenSSL/1.0.2k-fips SVN/1.7.14¢Ak¢DtypeEvalueMLast-ModifiedAv¢DtypeEvalueXSun, 20 May 2018 17:06:21 GMT¢Ak¢DtypeEvalueDETagAv¢DtypeEvalueT"5443-56ca634471d40"¢Ak¢DtypeEvalueDDateAv¢DtypeEvalueXFri, 01 Feb 2019 03:24:42 GMT¢Ak¢DtypeEvalueLContent-TypeAv¢DtypeEvalueXtext/html; charset=UTF-8Kraw_content¢DtypeEvalueYTC<?xml version="1.0" encoding="iso-8859-1"?>
<!DOCTYPE html PUBLIC
 "-//W3C//DTD XHTML 1.1//EN"
 "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">

<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en">

<head>
<meta http-equiv="content-type" content="text/html; charset=iso-8859-1" />
<link rel="stylesheet" href="../../course.css" type="text/css" />

<title>ICS 46 Spring 2018, Notes and Examples: Graph Traversals</title>

</head>

<body>

<div class="navbar">

<p>
ICS 46 Spring 2018 |
<a href="../../index.html">News</a> |
<a href="../../CourseReference.html">Course Reference</a> |
<a href="../../Schedule.html">Schedule</a> |
<a href="../../ProjectGuide">Project Guide</a> |
<a href="../../Notes">Notes and Examples</a> |
<a href="http://www.ics.uci.edu/~thornton/">About Alex</a>
</p>

<hr />

</div>

<div class="header">

<p>ICS 46 Spring 2018<br />
   Notes and Examples: Graph Traversals</p>

</div>

<div class="section">

<hr />

<p class="title">Traversing a graph</p>

<p>Previously, we learned about <a href="../TreeTraversals">tree traversals</a>, of which we saw two main variants: <i>depth-first traversals</i> and <i>breadth-first traversals</i>.  These kinds of traversals vary in terms of the order in which they visit the nodes in the tree:</p>

<ul>
  <li>Depth-first traversals visit nodes by following one path in the tree as far as it will go, then backtracking and trying a different path.</li>
  <li>Breadth-first traversals visit nodes in the order of how far they are away from the root.</li>
</ul>

<p>Graphs resemble trees in at least some ways, so it stands to reason that we might be able to use similar approaches to traverse them.  Of course, we've also seen that graphs differ from trees in some fairly significant ways.  Let's consider how each kind of traversal might work on a graph, and what we might have to do to tweak the tree traversal algorithms so that they would work on a graph instead.</p>

</div>

<div class="section">

<hr />

<p class="title">Depth-first graph traversals</p>

<p>Let's consider again how we do a depth-first traversal of a tree.  A sketch of the basic algorithm looks like this.</p>

<blockquote><pre>
DFT(Tree t):
    visit(root of t)
    for each subtree s of t:
        DFT(s)
</pre></blockquote>

<p>If we want to do something similar in a graph, we'll need to make some adjustments.  There are three things that will need to change:</p>

<ul>
  <li>One obvious adjustment is that we begin a depth-first tree traversal at a specially-designated node called the root.  But where is the root of a graph?  It turns out that graphs, in general, have no such notion; no one vertex is considered any more "special" than any other.  But if no vertex is particularly special, perhaps it doesn't matter where we start.</li>
  <li>At each step, we'll need two parameters: the whole graph <u>and</u> the vertex where we currently are.  (Why we don't need both in a tree is because trees have a root and subtrees that are trees, so passing a tree is enough to keep track of our current position; at any given time, we're at the root of some subtree.)</li>
  <li>Instead of looping over the subtrees of some tree, we'll instead loop over the vertices that we can reach via one outgoing edge from the current vertex.</li>
</ul>

<p class="subtitle">Our first attempt</p>

<p>Putting those ideas together, we arrive at the following sketch of a depth-first traversal algorithm for a graph.</p>

<blockquote><pre>
DFT(Graph g):
    let startVertex be any vertex in g
    DFTr(g, startVertex)

DFTr(Graph g, Vertex v):
    visit(v)
    for each vertex w such that the edge v &rarr; w exists:
        DFTr(g, w)
</pre></blockquote>

<p><b>DFT</b> is the complete algorithm; it's job is to traverse an entire graph.  <b>DFTr</b> can be seen as a recursive algorithm to do a partial traversal of all of the vertices that can be reached starting from the given vertex <b>v</b>.  (If you were implementing this in a C++ class, <b>DFT</b> would likely be a public member function, while <b>DFTr</b> might instead be a private member function that's used mainly as a helper.)</p>

<p>Try running through this algorithm on paper, using the graph below.  What result do you get if you use <i>a</i> as the start vertex?</p>

<p class="center"><img src="GraphTraversals_Example1.png" alt="Example 1" /></p>

<p>So far so good.  One possible outcome is <i>abecdfg</i>.  Your result may differ depending on which order you iterated through the available edges from each vertex, but you should have visited every vertex exactly once.</p>

<p>Now try the same algorithm on this graph instead.  What result do you get if you use <i>a</i> as the start vertex?</p>

<p class="center"><img src="GraphTraversals_Example2.png" alt="Example 2" /></p>

<p>This time, if you followed the algorithm faithfully as we described it above, you may have noticed that the result was more problematic.  Because this graph has what we've called splits-and-joins in it, we end up visiting some of the vertices more than once.  (For example, one possible outcome would be <i>abefdfgcdfg</i>.)  That's an issue we'll need to rectify.</p>

<p>Finally, try the same algorithm on this graph.  What result do you get if you use <i>a</i> as the start vertex?</p>

<p class="center"><img src="GraphTraversals_Example3.png" alt="Example 3" /></p>

<p>This is even more problematic.  If you're running through the algorithm the way we wrote it, you may have noticed that you'd slip into infinite recursion, due to the fact that this graph contains a cycle; once you reach the vertex <i>d</i>, you'll forever recurse through the cycle involving the vertices <i>d</i>, <i>f</i>, and <i>g</i>.</p>

<p>So we have some work to do to clean this up a bit.</p>

<p class="subtitle">Tracking where we've been</p>

<p>We can solve both the splits-and-joins and cycle problems simultaneously by introducing an additional trick.  If we keep track of the vertices we've visited and never allow ourselves to recurse forward to a vertex we've already visited, then neither splits-and-joins nor cycles will be a problem for us; our algorithm will naturally avoid both situations.  Here's an updated version of our algorithm that handles that problem.</p>

<blockquote><pre>
DFT(Graph g):
    for each vertex v in g:
        v.visited = false

    let startVertex be any vertex in g
    DFTr(g, startVertex)

DFTr(Graph g, Vertex v):
    visit(v)
    v.visited = true

    for each vertex w such that the edge v &rarr; w exists:
        if not w.visited:
            DFTr(g, w)
</pre></blockquote>

<p>We've introduced the notion of a <b>visited</b> value associated with each vertex.  In practice, this may not be implemented as a member variable or member function of each vertex; instead, this might be tracked as a separate collection (e.g., an array of <b>bool</b> values).  But the key here is that we have to keep track of which vertices we've visited, so we can avoid revisiting ones that we've already seen.</p>

<p>Try our new algorithm on the graphs above, again using <i>a</i> as the start vertex each time.  Verify that this has solved the problem.</p>

<p>Now try our new algorithm again on any of the graphs above, but using <i>b</i> as the start vertex instead.  Unfortunately, we've been met with an additional problem; if you start with a vertex from which all other vertices can't be reached, then there are vertices you'll never visit during your traversal.  Why we never had this problem with trees is because we always started at the root, and all nodes are always reachable from the root; that's guaranteed, by definition, in a tree.  Graphs, on the other hand, don't make that kind of promise, so we'll need to work around the issue ourselves.</p>

<p class="subtitle">Completing our algorithm design</p>

<p>Ensuring that we visit every vertex is a simple matter of allowing ourselves to use <b>DFTr</b> repeatedly.  A simple definition of <b>DFTr(g, v)</b> is this: <i>Visit every vertex in the graph g that is reachable from the vertex v, except for the ones we've visited before</i>.  So, if we don't visit every vertex the first time, we should try it again, starting from some vertex that we didn't reach previously.  This continues until there are no more vertices that we haven't visited.</p>

<p>The final design of our algorithm looks like this.</p>

<blockquote><pre>
DFT(Graph g):
    for each vertex v in g:
        v.visited = false

    for each vertex v in g:
        if not v.visted:
            DFTr(g, v)

DFTr(Graph g, Vertex v):
    visit(v)
    v.visited = true

    for each vertex w such that the edge v &rarr; w exists:
        if not w.visited:
            DFTr(g, w)
</pre></blockquote>

<p>In other words, we first mark all vertices as unvisited.  Next, we call <b>DFTr</b> on some unvisited vertex and let it work its way through all of the vertices it's able to reach.  When we return from the first call to <b>DFTr</b>, we go back into the second loop in <b>DFT</b> and look for a vertex we haven't visited.  When we find one, we call <b>DFTr</b> again.  This process repeats until every vertex is considered, at which point every vertex will have been visited.</p>

<p>Try this complete version of <b>DFT</b> on the graphs above; try each one a couple of times using a different start vertex each time.  You should see that this algorithm will visit every vertex exactly once in a generally depth-first order, i.e., by walking forward along one path until a dead end is reached, then backtracking and trying a different path, and so on, until every vertex has been reached.</p>

<p class="subtitle">Asymptotic analysis</p>

<p>Now that we've got a complete depth-first graph traversal algorithm, we should consider how long this algorithm might take to run.  Even though we've sketched pseudocode, this will be a little more complicated than a simple trick like using multiplication every time we see a loop.  What we need to understand is the totality of what the algorithm does.  There are a few important facts that underlie the analysis:</p>

<ul>
  <li>A complete traversal visits every vertex exactly once.</li>
  <li>When a vertex is visited, it's necessary to find all of its outgoing edges.</li>
  <li>Overall, the algorithm enumerates all of the edges in the graph exactly once.</li>
</ul>

<p>Let's break down the various parts of what this algorithm does, and separately analyze each.  We can then add these analyses together to determine a final, overall result.</p>

<table class="normal">
  <tr class="top">
    <td>Part</td>
    <td>Adj.&nbsp;Matrix</td>
    <td>Adj.&nbsp;Lists</td>
    <td>Commentary</td>
  </tr>
  <tr>
    <td>Marking&nbsp;all&nbsp;vertices&nbsp;unvisited</td>
    <td>&Theta;(<i>v</i>)</td>
    <td>&Theta;(<i>v</i>)</td>
    <td>This is the loop that initially sets <b>visited</b> to false for each vertex.</td>
  </tr>
  <tr>
    <td>Deciding&nbsp;whether&nbsp;to&nbsp;call&nbsp;<b>DFTr</b>&nbsp;on&nbsp;each&nbsp;vertex</td>
    <td>&Theta;(<i>v</i>)</td>
    <td>&Theta;(<i>v</i>)</td>
    <td>This is the loop that optionally calls <b>DFTr</b> on each vertex, if it hasn't been visited yet.  Not counted here is the time it takes to do the actual work of <b>DFTr</b>; we'll count that separately.</td>
  </tr>
  <tr>
    <td>Visiting&nbsp;all&nbsp;vertices</td>
    <td>&Theta;(<i>v</i>)</td>
    <td>&Theta;(<i>v</i>)</td>
    <td>This makes the reasonable assumption that visiting each vertex takes &Theta;(1) time.  (That's not to say that visits are necessarily fast, but that the time it takes to visit one vertex isn't a function of the number of vertices or the number of edges.)
  </tr>
  <tr>
    <td>Enumerating&nbsp;all&nbsp;edges</td>
    <td>&Theta;(<i>v</i><sup><small>2</small></sup>)</td>
    <td>&Theta;(<i>v</i>&nbsp;+&nbsp;<i>e</i>)</td>
    <td>This is where the implementation makes a difference.  An adjacency matrix would require us to enumerate all <i>possible</i> edges, whether they're in the graph or not; adjacency lists would require us only enumerate the edges that are actually there.</td>
  </tr>
  <tr>
    <td><b>TOTAL</b></td>
    <td><b>&Theta;(<i>v</i><sup><small>2</small></sup>)</b></td>
    <td><b>&Theta;(<i>v</i>&nbsp;+&nbsp;<i>e</i>)</b></td>
  </tr>
</table>

<p>To analyze how much memory we need, we'll need to think about what we would be spending the memory on.</p>

<ul>
  <li>&Theta;(<i>v</i>) memory to store the <b>visited</b> flags for each vertex.  (It's probably a small constant factor of <i>v</i>, but a constant factor of <i>v</i> nonetheless.)</li>
  <li>The stack associated with the recursion could potentially get as deep as the number of vertices, if there's one path that leads through every vertex from the start vertex.  So the stack will require <i>O</i>(<i>v</i>) memory.</li>
</ul>

<p>So, in total, we'll use &Theta;(<i>v</i>) memory &mdash; above and beyond the memory used by the graph &mdash; to perform the traversal.</p>

<p class="subtitle">Using a depth-first traversal to find cycles</p>

<p>Depth-first graph traversals have application besides just visiting every vertex; they also form the basis of a number of seemingly unrelated graph algorithms.  One example is determining whether a directed graph has any cycles (i.e., whether it qualifies as a DAG).</p>

<p>There is a key insight that can help us to define a cycle-finding algorithm.  In a depth-first traversal, there's always the <i>current path</i>, a path leading from the place you started to the place you are.  As you recurse forward, that path gets longer; as you backtrack, that path gets shorter.  But there is always such a path.</p>

<p>So how do you know when you've found a cycle?  What if you find an edge leading to a vertex that's already on the current path?  Necessarily, that means there's a cycle.  And note, additionally, that the presence of a cycle will always lead to this circumstance; the first time you reach one of the vertices in the cycle, you'll ultimately find that cycle.</p>

<p>Now the only question is how to efficiently check whether a vertex is in the current path.  We'll do that by keeping a separate flag called <b>onPath</b> for each vertex.  The flag starts out <b>false</b>, then we'll set it to <b>true</b> when we move forward to some vertex and then back to <b>false</b> when we backtrack away from it.  This way, the set of all vertices for which <b>onPath</b> is <b>true</b> would be our current path.</p>

<p>The algorithm, then, would be a modification to our <b>DFT</b> algorithm.  We no longer need the <b>visit</b> step, if all we're interested in is whether there is a cycle.</p>

<blockquote><pre>
DFT(Graph g):
    for each vertex v in g:
        v.visited = false
        v.onPath = false

    for each vertex v in g:
        if not v.visted:
            DFTr(g, v)

DFTr(Graph g, Vertex v):
    v.visited = true
    v.onPath = true

    for each vertex w such that the edge v &rarr; w exists:
        if not w.visited:
            DFTr(g, w)
        if w.onPath:
            <i>CYCLE FOUND</i>

    v.onPath = false
<pre></blockquote>

<p>If, in this algorithm, we reach the line that says <b>CYCLE FOUND</b>, we've found a cycle; if we never reach that line, there is no cycle in the graph.</p>

<p>Nothing we did here changes the asymptotic analysis for this algorithm &mdash; instead of changing one flag each time we reach a vertex, we change two (and then eventually change one back).  So we'd say that this takes &Theta;(<i>v</i><sup><small>2</small></sup>) time if the graph is implemented using an adjacency matrix, or &Theta;(<i>v</i> + <i>e</i>) if implemented using adjacency lists.</p>

</div>

<div class="section">

<hr />

<p class="title">Breadth-first graph traversals</p>

<p>As we saw when we were learning about tree traversals, another option is a breadth-first traversal.  And, indeed, we can do a <i>breadth-first graph traversal</i>, as well, based on the same principle: Visit the vertices in the order of how far they are away from the place you started.  The algorithm, like its tree-traversing counterpart, uses a queue to keep track of the next vertices it should visit.  Each time it visits a vertex, it enqueues the vertices that can be reached from that vertex &mdash; importantly skipping vertices that have already been visited or enqueued, so we don't visit the same vertex twice.</p>

<p>A sketch of the algorithm follows:</p>

<blockquote><pre>
BFT(Graph g, Vertex startVertex):
    for each vertex v in g:
        v.visited = false

    let q be an empty queue
    q.enqueue(startVertex)

    while not q.isEmpty():
        v = q.dequeue()
        visit(v)
        v.visited = true

        for each vertex w such that the edge v &rarr; w exists:
            if not w.visited and not q.contains(w):
                q.enqueue(w)
</pre></blockquote>

<p>It's important to note that this algorithm will only reach vertices that are connected to the vertex you start from, though this is quite often a feature rather than a bug.  A typical application of a breadth-first graph traversal is to find other vertices that are nearby, or to find the smallest number of edges you'd need to follow in order to get from one vertex to another.  In these kinds of circumstances, disconnected vertices &mdash; those you can't reach from the start vertex &mdash; are not something you're generally interested in.  (If you really do want a breadth-first traversal of the entire graph, you can use a similar trick to the one we used in our depth-first algorithm, by continuing the traversal from some other unvisited vertex when you have nowhere left to go.)</p>

<p class="subtitle">Asymptotic analysis</p>

<p>Ultimately, the time it takes to run this algorithm will be the same as the time required to run a depth-first traversal, as long as it's not expensive to ask the question of whether the queue contains some vertex.  (One way to make that into a &Theta;(1) operation would be to track this as an additional <b>enqueued</b> flag on each vertex.)  If this can be done in &Theta;(1) time, the total time would be:</p>

<ul>
  <li><i>O</i>(<i>v</i><sup><small>2</small></sup>) if the graph is implemented as an adjacency matrix</li>
  <li><i>O</i>(<i>v</i> + <i>e</i>) if the graph is implemented as adjacency lists</li>
</ul>

<p>The reasons are fairly similar to the analysis of our depth-first traversal.  The reason we say <i>O</i> instead of &Theta; is that not all of the vertices may be connected to the start vertex, so we may not end up traversing the whole graph.</p>

<p>Considering the memory usage of breadth-first traversal leads to a similar result as a depth-first traversal.</p>

<ul>
  <li>We would need &Theta;(<i>v</i>) memory to store the <b>visited</b> flag (and possibly also an <b>enqueued</b> flag) for every vertex.</li>
  <li>Additionally, we'd need the memory for the queue, which might quickly have almost every vertex in it if the graph is quite dense.  The queue, generally, would use <i>O</i>(<i>v</i>) memory.</li>
</ul>

<p>So, in total, we'd need &Theta;(<i>v</i>) memory, though the constant factor on the <i>v</i> might be quite small if the queue never gets large.  And, in practice, we would tend to use this algorithm when two things are true:</p>

<ul>
  <li>We're not necessarily interested in reaching every vertex; instead, we're primarily concerned with vertices that are relatively close (e.g., LinkedIn finding all of the people that are within two or three connections from you).</li>
  <li>The graph is relatively sparse (i.e., most vertices don't have edges to most others).</li>
</ul>

<p>In those circumstances, the behavior will be reasonable enough.  And even an extra &Theta;(<i>v</i>) memory isn't that big of a deal alongside a data structure that's already bigger than that to begin with.</p>

</div>

<div class="section">

<hr />

<p class="title">How else might we traverse graphs?</p>

<p>Because graphs are organized differently from trees, it stands to reason that there might be other ways to traverse them that are neither depth-first nor breadth-first.  Depth-first and breadth-first traversals have their uses, forming the basis of a variety of graph algorithms.

<p>But if our only goal is to simply visit every vertex, for example, we'll generally have a data structure that gives us that information directly.  In an adjacency matrix implementation, there is generally a one-dimensional array, ancillary to the matrix itself, that stores vertex information; that array could simply be traversed linearly.  If an adjacency lists implementation, the one-dimensional array that forms the basis of the implementation could be traversed linearly.</p>

<p>If our goal is to visit every edge in no particular order, we could similarly traverse the underlying data structure &mdash; adjacency matrix or adjacency lists &mdash; directly.</p>

<p>How you choose from among these options depends on the problem you're trying to solve.  The best thing is to understand what the choices are &mdash; depth-first, breadth-first, or something more direct &mdash; and which scenarios might be appropriate for each.</p>

</div>

</body>
</html>
Mis_redirected¢DtypeEvalueõIhttp_code¢DtypeEvalueÈQdownload_complete¢DtypeEvalueõ