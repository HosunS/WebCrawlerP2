¦Ifinal_url¢DtypeEvaluexAhttps://www.ics.uci.edu/~thornton/ics46/Notes/StacksQueuesDeques/Lhttp_headers¢DtypeEvalue‡¢Ak¢DtypeEvalueNContent-LengthAv¢DtypeEvalueE26180¢Ak¢DtypeEvalueMAccept-RangesAv¢DtypeEvalueEbytes¢Ak¢DtypeEvalueFServerAv¢DtypeEvalueX4Apache/2.4.6 (CentOS) OpenSSL/1.0.2k-fips SVN/1.7.14¢Ak¢DtypeEvalueMLast-ModifiedAv¢DtypeEvalueXSun, 08 Apr 2018 19:47:22 GMT¢Ak¢DtypeEvalueDETagAv¢DtypeEvalueT"6644-5695b8ec88680"¢Ak¢DtypeEvalueDDateAv¢DtypeEvalueXFri, 01 Feb 2019 03:24:33 GMT¢Ak¢DtypeEvalueLContent-TypeAv¢DtypeEvalueXtext/html; charset=UTF-8Kraw_content¢DtypeEvalueYfD<?xml version="1.0" encoding="iso-8859-1"?>
<!DOCTYPE html PUBLIC
 "-//W3C//DTD XHTML 1.1//EN"
 "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">

<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en">

<head>
<meta http-equiv="content-type" content="text/html; charset=iso-8859-1" />
<link rel="stylesheet" href="../../course.css" type="text/css" />

<title>ICS 46 Spring 2018, Notes and Examples: Stacks, Queues, and Deques</title>

</head>

<body>

<div class="navbar">

<p>
ICS 46 Spring 2018 |
<a href="../../index.html">News</a> |
<a href="../../CourseReference.html">Course Reference</a> |
<a href="../../Schedule.html">Schedule</a> |
<a href="../../ProjectGuide">Project Guide</a> |
<a href="../../Notes">Notes and Examples</a> |
<a href="http://www.ics.uci.edu/~thornton/">About Alex</a>
</p>

<hr />

</div>

<div class="header">

<p>ICS 46 Spring 2018<br />
   Notes and Examples: Stacks, Queues, and Deques</p>

</div>

<div class="section">

<hr />

<p class="title">Identifying the right data structure</p>

<p>In previous coursework, you've no doubt used at least one programming language &mdash; C++ or something else &mdash; enough that you've been exposed to the data structures that are provided by the language or its standard library.  For example, C++ provides a number of data structures: arrays, <b>std::vector</b>, <b>std::list</b>, and <b>std::map</b>, to name a few.  Python, meanwhile, provides choices like lists, sets, tuples, and dictionaries.  None of these is definitively better than any of the others; the objective is to choose the data structure that best matches the "shape" of the problem you're trying to solve.  If you want to store a sequence of values in Python, a list is a good choice.  If you want to keep track of information about students, each indexed uniquely by an ID, in C++, you might choose a <b>std::map</b>, with the keys being the IDs and the values being objects of a Student class.</p>

<p>Generally, then, when we learn about a new data structure we've not seen before, there are a few things we want to understand about it:</p>

<ul>
  <li>What kinds of problems is it indended to solve?  What does it look like, from a conceptual perspective?</li>
  <li>What are the <i>common operations</i> (i.e., the things that any reasonable implementation of the data structure would provide), and what do they do, from a conceptual perspective?</li>
  <li>How would the implementation of the common operations actually work?  If you need to store data in memory, for example, how would you organize it, and how would you find and manipulate it as it changes?</li>
  <li>How <i>well</i> would the implementation of the common operations work?  We should do some analysis (e.g., asymptotic analysis) of our implementation choices, to be sure that we've made good ones, and to be able to compare different implementations, so we can select one that performs well enough for our needs.</li>
</ul>

<p>If we can get a handle on all of those issues, we'll have a good understanding of when our new data structure might solve a real problem we have, as well as how we should build it (if our preferred programming language doesn't provide one), and how well it will perform in the ways that we plan to use it.</p>

<p>To get our minds around this kind of analysis, let's consider a few of the classic <i>linear data structures</i>, which let you store and manipulate sequences of elements, with the understanding that certain ones, at any given time, are more important than the others.</p>

</div>

<div class="section">

<hr />

<p class="title">Stacks</p>

<p>A <i>stack</i> is a data structure that stores a sequence of elements, with the key property being that the most important one, at any given time, is the one that was stored the <i>most recently</i>.  If we were to draw a diagram of a stack, which focused on the key concepts, it might look something like this:</p>

<p class="center"><img src="StackConceptual.png" alt="Stack (Conceptual View)" /></p>

<p>The diagram shows the most important conceptual ideas underlying stacks:</p>

<ul>
  <li>The most important element is the one on top.</li>
  <li>The common operation <b>push</b> adds a new element to the top.</li>
  <li>The common operation <b>pop</b> removes an element from the top.</li>
  <li>The common operation <b>top</b> lets us view the topmost element without removing it.</li>
</ul>

<p>In a practical implementation, you might find other operations, like one that tells you how many elements are in the stack, or one that tells you whether the stack is empty, but <b>push</b>, <b>pop</b>, and <b>top</b> are the most important ones, so we'll focus on those.</p>

<p>If we have a stack-shaped problem and we need to implement one, we have a sequence of elements to store; our first order of business is choosing an underlying data structure in which to store them.  There are two obvious choices: an array (or an array-based structure, like a <b>std::vector</b>) and a linked list.</p>

<p class="subtitle">Implementing a stack using an array or std::vector</p>

<p>Let's first consider how you might implement a stack using an array-based data structure, such as an array or a <b>std::vector</b>.  It seems sensible that we'd want to store the elements in the order in which they appear in the stack, though an open question is whether they should be stored in top-to-bottom or bottom-to-top order.  Let's think about each option.</p>

<p>If we store the elements in top-to-bottom order, that means the top of the stack would always be stored in cell 0 of the array, the element just beneath the top would be stored in cell 1, and so on.  We'd presumably also need to keep track of how many elements were stored (necessary if we had an array, done automatically by <b>std::vector</b> if we use it).  This approach has the upside that we always know where the top element is &mdash; it'll always be in cell 0, no matter what.  To understand whether this is a good approach, though, we should do some analysis; we'll analyze the three common operations, assuming there are <i>n</i> elements stored in the stack already.</p>

<ul>
  <li><b>top</b>: The topmost element will always be in cell 0, which we'll be able to access in constant time, no matter how many elements are stored.  So, &Theta;(1) time.</li>
  <li><b>push</b>: The newly-pushed element will need to be stored in cell 0, but we'll first need to slide everything over to make space.  This will require &Theta;(<i>n</i>) time.</li>
  <li><b>pop</b>: After removing the top element, everything else will need to slide backward to fill the open space.  This, too, will require &Theta;(<i>n</i>) time.</li>
</ul>

<p>The fundamental problem is the requirement that the topmost element is always in cell 0; the "business end" of the stack being in a fixed position requires us to slide elements back and forth.  But if we flip the elements around, instead storing the <i>bottommost</i> element in cell 0, we could always easily infer the position of the top element by looking at the stack's size (which we'd be tracking separately).  Is this better?  Let's take a look, again assuming there are <i>n</i> elements stored in the stack.</p>

<ul>
  <li><b>top</b>: The topmost element will always be in cell indexed by <b>size &minus; 1</b>, which we could find in constant time.  Still &Theta;(1).</li>
  <li><b>push</b>: The value of <b>size</b> would tell us where to put the new element, then we could increment the size.  In an array, this would take &Theta;(1) time.  In a <b>std::vector</b>, it's a little more complicated, because this sometimes requires a reallocation (when the <b>std::vector</b> has run out of space); we'll talk more about that in a later set of notes.</li>
  <li><b>pop</b>: Similarly, removing from the end of an array-based data structure, given that we know its size, is a &Theta;(1) operation &mdash; blanking/nulling out some cell and then decrementing the size.</li>
</ul>

<p>So, the simple act of reversing the order of the elements made a huge difference!  This is why it's so important for us to do a little bit of analysis, because we quickly discover that reasonable-sounding ideas ("If the top of the stack was in cell 0, we'd always be able to find it!") sometimes lead to sub-par solutions.</p>

<p class="subtitle">Implementing a stack using a linked list</p>

<p>If we instead opt to implement a stack using a linked list, our first order of business is selecting what kind of linked list we should use.  We saw previously that there are variants on the idea of a linked list.  The key question is this:  What is the simplest kind of linked list that still yields the best possible performance for the common operations?</p>

<p>So, let's start with the simplest kind of linked list we know: a singly-linked list with head.  What we've seen is that certain operations, notably the ones that work near the front of the list, are performant; others less so.  So if we could make sure that we were only ever modifying the front of the list, we'd be in good shape.</p>

<p>That turns out to be an easy problem to solve, by arranging the elements so that the top of the stack is in the first node of the list, with the others stored sequentially afterward.  If there are <i>n</i> elements in our stack, we'd see the following performance characteristics.</p>

<ul>
  <li><b>top</b>: Getting the value in the first node is a constant-time operation.  So, &Theta;(1).</li>
  <li><b>push</b>: This would equate to adding a node to the front of the list.  Also &Theta;(1).</li>
  <li><b>pop</b>: This would equate to removing the node from the front of the list.  &Theta;(1).</li>
</ul>

<p>The moral of the story is that the simplest kind of linked list would be sufficient to solve this problem reasonably well.  That isn't to say that we couldn't use a more complex one &mdash; if, for example, we already had one implemented and tested &mdash; but knowing the minimum requirement tells us what we would have to build, at minimum, if we had to build it ourselves, or if we could select from many different prebuilt implementations.</p>

</div>

<div class="section">

<hr />

<p class="title">Queues</p>

<p>A <i>queue</i> is a data structure that stores a sequence of elements, with the key property that the most important one, at any given time, is the one that was stored the <i>least recently</i>.  Elements "wait in line" in the order they arrive.  If we were to draw a diagram of a queue, which focused on the key concepts, it might look something like this:</p>

<p class="center"><img src="QueueConceptual.png" alt="Queue (Conceptual View)" /></p>

<p>The diagram shows the most important conceptual ideas underlying queues:</p>

<ul>
  <li>The most important element is the one in the front.</li>
  <li>The common operation <b>enqueue</b> adds a new element to the back.</li>
  <li>The common operation <b>dequeue</b> removes an element from the front, which will naturally be the one that's been in the queue the longest.</li>
  <li>The common operation <b>front</b> lets us view the front element without removing it.</li>
</ul>

<p>As with stacks, a practical queue implementation might include other operations, such as the ability to determine how many elements are stored, but <b>enqueue</b>, <b>dequeue</b>, and <b>front</b> are the most important ones, so we'll focus our attention on those.</p>

<p>If we've got a queue-shaped problem and need to implement one ourselves, we'll need to map the concept to an implementation technique; importantly, we'll need to choose an underlying data structure in which to store the elements, and we'll need to arrange the elements in that data structure to provide performant operations.</p>

<p class="subtitle">Implementing a queue using a linked list</p>

<p>As we did when we were considering how to implement a stack, we should decide which is the simplest kind of linked list that will lead to a favorable outcome; ideally, we could find a way to implement all three of the common operations so they could run in &Theta;(1) time.</p>

<p>Your intuition should kick in quickly when you consider whether a singly-linked list with head would provide a good solution to this problem.  Queues have two "business ends"; we enqueue at the back and dequeue from the front.  So, without thinking very hard about it, we can eliminate a singly-linked list with head from consideration, because it doesn't provide constant-time access to both ends of the list, which means that either enqueues or dequeues will be more expensive than they ought to be.</p>

<p>A singly-linked list with head and tail, on the other hand, at least seems like it has a chance at providing &Theta;(1) enqueue, dequeue, and front operations, because it at least gives us constant-time access to both ends of the list.  But we have to think through what we can and can't do in &Theta;(1) time, given a singly-linked list with head and tail:</p>

<ul>
  <li>Access the data in the first node</li>
  <li>Access the data in the last node</li>
  <li>Add to the front of the list</li>
  <li>Remove from the front of the list</li>
  <li>Add to the end of the list</li>
</ul>

<p>Notably absent is the ability to remove from the end of the list, which requires &Theta;(<i>n</i>) time in a list with <i>n</i> nodes.  So we'd best avoid that operation.  Nonetheless, if we choose our organization of elements in nodes carefully, we can still achieve the outcome we want.  If we store the front element of the queue in the first node, the back element of the queue in the last node, and the remaining nodes (in the proper order) in between, then we're in business.</p>

<ul>
  <li><b>front</b>: Access the data in the first node of the list.  &Theta;(1) time.</li>
  <li><b>enqueue</b>: Add a new node to the end of the list.  &Theta;(1) time.</li>
  <li><b>dequeue</b>: Remove a node from the beginning of the list.  &Theta;(1) time.</li>
</ul>

<p class="subtitle">Implementing a queue using an array or std::vector</p>

<p>We should consider, too, how you might use an array-based data structure, like an array or a <b>std::vector</b>, to implement a queue.  Perhaps surprisingly, this is more complicated than it sounds, so we'll need to exercise some caution and think through some of the details carefully.</p>

<p>First of all, we can eliminate <b>std::vector</b> from consideration almost immediately.  Used the way it's intended to be used, a <b>std::vector</b> stores its <i>s</i> elements into an underlying array of capacity <i>c</i>, where <i>c</i> &ge; <i>s</i>.  If you ask it for its size, you'll get back <i>s</i>; if you ask for its capacity, you'll get back <i>c</i>.  And the <i>s</i> elements will always be stored in the first <i>s</i> cells of the underlying array, the first one in cell 0, the second in cell 1, and so on.</p>

<p>So why does this eliminate <b>std::vector</b> as a good choice for solving this problem?  Consider how you might solve it.</p>

<ul>
  <li>Store the elements of the queue in front-to-back order in the <b>std::vector</b>, meaning the front element of the queue will always be in cell 0, while the back element of the queue will always be in cell <i>s</i> &minus; 1.</li>
  <li>Store the elements of the queue in back-to-front order in the <b>std::vector</b>, meaning the back element of the queue will always be in cell 0, while the front element of the queue will always be in cell <i>s</i> &minus; 1.</li>
</ul>

<p>Regardless of which of these you choose, you'll either have expensive enqueues or expensive dequeues:</p>

<ul>
  <li>If the elements are stored in front-to-back order, dequeuing would involve removing the first element from the <b>std::vector</b>, requiring all subsequent elements to be slid back to fill in the space.  This will take &Theta;(<i>s</i>) time.</li>
  <li>If the elements are stored in back-to-front order, enqueuing would involve adding a new first element to the <b>std::vector</b>, requiring all of the existing elements to be slid forward to create an empty space.  This will take &Theta;(<i>s</i>) time.</li>
</ul>

<p>While there are ways we could "abuse" <b>std::vector</b> to solve our problem, if we use it the way it's intended, the constraint that the <i>s</i> elements must be stored in the first <i>s</i> cells of the underlying array leads us to an impasse; there's simply no good solution to the problem using this tool.</p>

<p>If, instead, we consider arrays more generally, a somewhat different solution emerges.  What if, instead of forcing the front element to be stored in cell 0, we used an array, allowing us to relax that requirement?  In that case, we could keep track of the index of the front element of the queue, as well as the index where an element would be added to the back of the queue, and let those "float" over time as elements are enqueued and dequeued.  For example, the array-based queue below contains the three elements <i>x</i>, <i>y</i>, and <i>z</i>:</p>

<table class="normal">
  <tr class="top">
    <td>0</td>
    <td>1</td>
    <td>2</td>
    <td>3</td>
    <td>4</td>
    <td>5</td>
    <td>6</td>
  </tr>
  <tr>
    <td></td>
    <td>x</td>
    <td>y</td>
    <td>z</td>
    <td></td>
    <td></td>
    <td></td>
  </tr>
  <tr class="top">
    <td></td>
    <td>&uarr;<br />f</td>
    <td></td>
    <td></td>
    <td>&uarr;<br />b</td>
    <td></td>
    <td></td>
  </tr>
</table>

<p>In the diagram, <b>f</b> depicts the index of the front element and <b>b</b> depicts the index where a new element would be added to the back; you'd store these values as unsigned integers.  Given this scenario, the portion of the array that contains elements actually in the queue begins with the element where <b>f</b> refers and ends with the element <i>preceding</i> where <b>b</b> refers.</p>

<p>Enqueuing an element is simple, then: Store the element in the cell where <b>b</b> refers, then add 1 to <b>b</b>.  Dequeuing is similar: Clear the value in the cell where <b>f</b> refers, then add 1 to <b>f</b>.  Since arrays provide constant-time access to a cell, given its index, these will be &Theta;(1) time operations.  So far so good!</p>

<p>However, there are some wrinkles worth considering.  Given this implementation, both <b>f</b> and <b>b</b> will move forward over time.  So, eventually, you could end up in a situation like this one:</p>

<table class="normal">
  <tr class="top">
    <td>0</td>
    <td>1</td>
    <td>2</td>
    <td>3</td>
    <td>4</td>
    <td>5</td>
    <td>6</td>
  </tr>
  <tr>
    <td></td>
    <td></td>
    <td>w</td>
    <td>v</td>
    <td>t</td>
    <td>s</td>
    <td></td>
  </tr>
  <tr class="top">
    <td></td>
    <td></td>
    <td>&uarr;<br />f</td>
    <td></td>
    <td></td>
    <td></td>
    <td>&uarr;<br />b</td>
  </tr>
</table>

<p>Now suppose you want to enqueue another element.  What do we do with <b>b</b>?  If we add 1 to it, it'll be pointing beyond the boundaries of the array, so the next enqueue will fail.  So, instead, we "wrap" it back around to the beginning of the array:</p>

<table class="normal">
  <tr class="top">
    <td>0</td>
    <td>1</td>
    <td>2</td>
    <td>3</td>
    <td>4</td>
    <td>5</td>
    <td>6</td>
  </tr>
  <tr>
    <td></td>
    <td></td>
    <td>w</td>
    <td>v</td>
    <td>t</td>
    <td>s</td>
    <td>r</td>
  </tr>
  <tr class="top">
    <td>&uarr;<br />b</td>
    <td></td>
    <td>&uarr;<br />f</td>
    <td></td>
    <td></td>
    <td></td>
    <td></td>
  </tr>
</table>

<p>And we slightly redefine our idea of which elements are actually part of the queue, so that if <b>b</b> refers to a cell with a smaller index than <b>f</b>, everything from <b>f</b> through the end of the array <i>and</i> anything in a cell <i>preceding</i> <b>b</b> will be considered part of the queue.  Just as <b>b</b> can wrap around when it reaches the end and we enqueue an element, <b>f</b> can wrap around when it reaches the end and we dequeue one.  Over time, <b>f</b> and <b>b</b> chase each other around the array forever, and it becomes possible to enqueue and dequeue elements indefinitely, as long as we never dequeue from an empty queue or enqueue into a full one.</p>

<p>There's one last wrinkle.  How do we detect that the array is full?  Let's consider what it looks like just before it fills.</p>

<table class="normal">
  <tr class="top">
    <td>0</td>
    <td>1</td>
    <td>2</td>
    <td>3</td>
    <td>4</td>
    <td>5</td>
    <td>6</td>
  </tr>
  <tr>
    <td>q</td>
    <td></td>
    <td>w</td>
    <td>v</td>
    <td>t</td>
    <td>s</td>
    <td>r</td>
  </tr>
  <tr class="top">
    <td></td>
    <td>&uarr;<br />b</td>
    <td>&uarr;<br />f</td>
    <td></td>
    <td></td>
    <td></td>
    <td></td>
  </tr>
</table>

<p>So what would happen if we enqueued one more element?  We'd now be in the following situation.</p>

<table class="normal">
  <tr class="top">
    <td>0</td>
    <td>1</td>
    <td>2</td>
    <td>3</td>
    <td>4</td>
    <td>5</td>
    <td>6</td>
  </tr>
  <tr>
    <td>q</td>
    <td>p</td>
    <td>w</td>
    <td>v</td>
    <td>t</td>
    <td>s</td>
    <td>r</td>
  </tr>
  <tr class="top">
    <td></td>
    <td></td>
    <td>&uarr;&uarr;<br />f b</td>
    <td></td>
    <td></td>
    <td></td>
    <td></td>
  </tr>
</table>

<p>This suggests that we can detect "fullness" when <b>f</b> = <b>b</b>.  But what about emptiness?  Just before the queue is empty, it would look like this:</p>

<table class="normal">
  <tr class="top">
    <td>0</td>
    <td>1</td>
    <td>2</td>
    <td>3</td>
    <td>4</td>
    <td>5</td>
    <td>6</td>
  </tr>
  <tr>
    <td></td>
    <td></td>
    <td>q</td>
    <td></td>
    <td></td>
    <td></td>
    <td></td>
  </tr>
  <tr class="top">
    <td></td>
    <td></td>
    <td>&uarr;<br />f</td>
    <td>&uarr;<br />b</td>
    <td></td>
    <td></td>
    <td></td>
  </tr>
</table>

<p>If we dequeued an element, we would end up here.</p>

<table class="normal">
  <tr class="top">
    <td>0</td>
    <td>1</td>
    <td>2</td>
    <td>3</td>
    <td>4</td>
    <td>5</td>
    <td>6</td>
  </tr>
  <tr>
    <td></td>
    <td></td>
    <td></td>
    <td>&nbsp;</td>
    <td></td>
    <td></td>
    <td></td>
  </tr>
  <tr class="top">
    <td></td>
    <td></td>
    <td></td>
    <td>&uarr;&uarr;<br />f b</td>
    <td></td>
    <td></td>
    <td></td>
  </tr>
</table>

<p>And, suddenly, it becomes evident that <b>f</b> = <b>b</b> might also mean that the queue is empty.  So how do we tell the difference?  The answer lies in one simple tweak: We also keep track of the <i>size</i> of the queue at all times (i.e., the number of elements we're currently storing in the queue), incrementing and decrementing it as we enqueue and dequeue elements.  This gives us not only a simple solution to the problem of finding out how many elements we're storing, but it forms the basis of how we detect fullness and emptiness, by simply comparing <i>size</i> to the capacity of the array (which, in C++, we would also need to track separately).</p>

<p>This solution, generally, is called the <i>circular array implementation</i> of a queue, and is common in both software and hardware, particularly when there is a fixed amount of memory available.</p>

</div>

<div class="section">

<hr />

<p class="title">Deques (Double-Ended Queues)</p>

<p>I expect there's a good chance you've seen stacks and queues before, but there is another, slightly lesser-known "classic" linear data structure that you may never have seen, which is called a <i>deque</i>, an oddly-spelled name that is intended to be shorthand for <i>double-ended queue</i>.  The name "double-ended queue" is a pretty accurate description of what it is; it acts like a queue in which you can treat either end as the front and either end as the back, leading to the following common operations.</p>

<ul>
  <li><b>enqueueFront</b>: Add an element in front of all the others.</li>
  <li><b>enqueueBack</b>: Add an element behind all the others.</li>
  <li><b>dequeueFront</b>: Remove an element from the front.</li>
  <li><b>dequeueBack</b>: Remove an element from the back.</li>
  <li><b>front</b>: Access the element at the front, without removing it.</li>
  <li><b>back</b>: Access the element at the back, without removing it.</li>
</ul>

<p>While deques don't themselves fit as many "real-world" problems as stacks and queues, one very useful application of deques is as an underlying data structure on top of which others (notably, stacks and queues) can be built.  For example, the C++ Standard Library contains a <b>std::deque</b> class template for exactly this reason.</p>

<p class="subtitle">Implementing a deque using a linked list</p>

<p>Because a deque requires us to be able to add and remove elements at either end of the list, we'll need a doubly-linked list with head and tail to do so efficiently, because that's the only linked list variant we've seen that allows us to remove from either end in &Theta;(1) time.</p>

<p class="subtitle">Implementing a deque using an array or std::vector</p>

<p>Like queues, deques can't be effectively implemented using <b>std::vector</b> as it was intended to be used, because one end of the deque or the other would be required to be in cell 0 at all times.</p>

<p>However, we could do something very similar to the circular array implementation of a queue.  The only difference is that both <b>f</b> and <b>b</b> would be able to move in either direction, because both enqueuing and dequeing are possible at both ends of the queue.  Otherwise, the implementation would be very similar to the one we saw previously.</p>

</div>

</body>
</html>
Mis_redirected¢DtypeEvalueõIhttp_code¢DtypeEvalueÈQdownload_complete¢DtypeEvalueõ