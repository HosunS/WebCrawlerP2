¦Ifinal_url¡DtypeLhttp_headers¢DtypeEvalue‡¢Ak¢DtypeEvalueNContent-LengthAv¢DtypeEvalueD2503¢Ak¢DtypeEvalueMAccept-RangesAv¢DtypeEvalueEbytes¢Ak¢DtypeEvalueFServerAv¢DtypeEvalueX„Apache/2.4.6 (CentOS) OpenSSL/1.0.2k-fips SVN/1.7.14 mod_wsgi/3.4 Python/2.7.5 Phusion_Passenger/4.0.53 mod_perl/2.0.10 Perl/v5.16.3¢Ak¢DtypeEvalueMLast-ModifiedAv¢DtypeEvalueXWed, 17 Apr 2013 01:53:37 GMT¢Ak¢DtypeEvalueDETagAv¢DtypeEvalueS"9c7-4da84c118aa40"¢Ak¢DtypeEvalueDDateAv¢DtypeEvalueXSat, 09 Feb 2019 17:02:17 GMT¢Ak¢DtypeEvalueLContent-TypeAv¢DtypeEvalueXtext/plain; charset=UTF-8Kraw_content¢DtypeEvalueY	Ç/*
 $Id: storage.h 5833 2010-10-26 00:54:31Z abehm $
 
 Copyright (C) 2010 by The Regents of the University of California
 
 Redistribution of this file is permitted under
 the terms of the BSD license.
 
 Date: 11/01/2009
 Author: Shengyue Ji <shengyuj (at) ics.uci.edu>
*/

#include <stdio.h>
#include <vector>
#include <stdint.h>
#include <tr1/unordered_map>

using namespace std;
using namespace tr1;

// Buffers managed by Storage should extend this
class Buffer
{
public:
    // identifier of the buffer
    uintptr_t id;

    // size of the Buffer in bytes (including self)
    size_t size;
};

class Storage
{
    // id of the root buffer
    uintptr_t rootId;

    ////// * disk * storage specific
    // file descriptor for disk storage
    FILE *file;

    ////// disk mem storage specific
    // buffer for disk mem storage
    char *buffer;

    ////// mem disk storage specific
    // file size for mem disk storage
    unsigned size;
    unsigned size2;
    // buffer index for mem to disk storage (disk address -> index in buffers)
    unordered_map<unsigned, unsigned> index;
    // buffer array for mem to disk storage
    vector<Buffer *> buffers;

public:
    // usage for mem disk 2
    // 0: mem disk (for tree nodes)
    // 1: disk (for extension nodes)
    unsigned usage;

    // memory storage should use this
    Storage();

    // disk storage should use this
    // memory storage can also use this to load from disk
    Storage(const char *filename);

    ~Storage();

    // allocate a Buffer of size on the storage and return the buffer
    Buffer *alloc(size_t size);

    // deallocate the Buffer by id from storage
    void dealloc(uintptr_t id);

    // return the Buffer identified by id
    // disk storage should allocate Buffer also
    // memory storage should directly return the Buffer
    Buffer *read(uintptr_t id);

    // return a buffer (not a Buffer object) read from node id,
    // starting from offset (relative to the begining of the Buffer)
    char *readPart(uintptr_t id, unsigned offset, unsigned size);

    // write the Buffer identified by id to disk
    // memory storage should do nothing
    void write(const Buffer *buf);

    // free the Buffer returned from disk read and allocation
    // memory storage should do nothing
    void free(Buffer *buf);

    // return the buffer id of the root
    unsigned getRoot();

    // set the buffer id of the root
    // disk storage should also write to file
    void setRoot(uintptr_t id);

};

Mis_redirected¢DtypeEvalueôIhttp_code¢DtypeEvalueÈQdownload_complete¢DtypeEvalueõ