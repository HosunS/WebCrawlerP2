¦Ifinal_url¡DtypeLhttp_headers¢DtypeEvalue‰¢Ak¢DtypeEvalueNContent-LengthAv¢DtypeEvalueE41120¢Ak¢DtypeEvalueJSet-CookieAv¢DtypeEvalueX°trac_form_token=418a1444616a8941c6d6a52c; httponly; Path=/wiki/public, trac_session=008e0cd911cd0f631f0f9dce; expires=Wed, 01 May 2019 14:04:59 GMT; httponly; Path=/wiki/public¢Ak¢DtypeEvalueGExpiresAv¢DtypeEvalueXFri, 01 Jan 1999 00:00:00 GMT¢Ak¢DtypeEvalueJKeep-AliveAv¢DtypeEvalueRtimeout=5, max=100¢Ak¢DtypeEvalueFServerAv¢DtypeEvalueX„Apache/2.4.6 (CentOS) OpenSSL/1.0.2k-fips SVN/1.7.14 mod_wsgi/3.4 Python/2.7.5 Phusion_Passenger/4.0.53 mod_perl/2.0.10 Perl/v5.16.3¢Ak¢DtypeEvalueJConnectionAv¢DtypeEvalueJKeep-Alive¢Ak¢DtypeEvalueMCache-ControlAv¢DtypeEvalueOmust-revalidate¢Ak¢DtypeEvalueDDateAv¢DtypeEvalueXThu, 31 Jan 2019 14:04:59 GMT¢Ak¢DtypeEvalueLContent-TypeAv¢DtypeEvalueWtext/html;charset=utf-8Kraw_content¢DtypeEvalueY  <!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
  
  


  <head>
    <title>
      cs222-2018-fall-project4 â€“ Public
    </title>
      <meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
      <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <!--[if IE]><script type="text/javascript">
      if (/^#__msie303:/.test(window.location.hash))
        window.location.replace(window.location.hash.replace(/^#__msie303:/, '#'));
    </script><![endif]-->
        <link rel="search" href="/wiki/public/search" />
        <link rel="help" href="/wiki/public/wiki/TracGuide" />
        <link rel="alternate" href="/wiki/public/wiki/cs222-2018-fall-project4?format=txt" type="text/x-trac-wiki" title="Plain Text" />
        <link rel="tracwysiwyg.base" href="/wiki/public" />
        <link rel="start" href="/wiki/public/wiki" />
        <link rel="stylesheet" href="/wiki/public/chrome/common/css/trac.css" type="text/css" /><link rel="stylesheet" href="/wiki/public/chrome/common/css/wiki.css" type="text/css" /><link rel="stylesheet" href="/wiki/public/chrome/tracwysiwyg/wysiwyg.css" type="text/css" />
        <link rel="tracwysiwyg.stylesheet" href="/wiki/public/chrome/common/css/trac.css" /><link rel="tracwysiwyg.stylesheet" href="/wiki/public/chrome/tracwysiwyg/editor.css" />
        <link rel="shortcut icon" href="/wiki/public/chrome/site/favicon.ico" type="image/x-icon" />
        <link rel="icon" href="/wiki/public/chrome/site/favicon.ico" type="image/x-icon" />
    <style id="trac-noscript" type="text/css">.trac-noscript { display: none !important }</style>
    <script type="text/javascript">
      var _tracwysiwyg={};
    </script>
      <script type="text/javascript" charset="utf-8" src="/wiki/public/chrome/common/js/jquery.js"></script>
      <script type="text/javascript" charset="utf-8" src="/wiki/public/chrome/common/js/babel.js"></script>
      <script type="text/javascript" charset="utf-8" src="/wiki/public/chrome/common/js/trac.js"></script>
      <script type="text/javascript" charset="utf-8" src="/wiki/public/chrome/common/js/search.js"></script>
      <script type="text/javascript" charset="utf-8" src="/wiki/public/chrome/common/js/folding.js"></script>
      <script type="text/javascript" charset="utf-8" src="/wiki/public/chrome/tracwysiwyg/wysiwyg.js"></script>
    <script type="text/javascript">
      jQuery("#trac-noscript").remove();
      jQuery(document).ready(function($) {
        $(".trac-autofocus").focus();
        $(".trac-target-new").attr("target", "_blank");
        setTimeout(function() { $(".trac-scroll").scrollToTop() }, 1);
        $(".trac-disable-on-submit").disableOnSubmit();
      });
    </script>
    <script type="text/javascript">
      jQuery(document).ready(function($) {
        $("#content").find("h1,h2,h3,h4,h5,h6").addAnchor(_("Link to this section"));
        $("#content").find(".wikianchor").each(function() {
          $(this).addAnchor(babel.format(_("Link to #%(id)s"), {id: $(this).attr('id')}));
        });
        $(".foldable").enableFolding(true, true);
      });
    </script>
  </head>
  <body>
    <div id="banner">
      <div id="header">
        <a id="logo" href="http://www.ics.uci.edu/"><img src="/wiki/public/chrome/site/ics.jpg" alt="ICS Logo" height="67" width="128" /></a>
      </div>
      <form id="search" action="/wiki/public/search" method="get">
      </form>
      <div id="metanav" class="nav">
    <ul>
      <li class="first"><a href="/wiki/public/login">Login</a></li><li><a href="/wiki/public/prefs">Preferences</a></li><li class="last"><a href="/wiki/public/about">About Trac</a></li>
    </ul>
  </div>
    </div>
    <div id="mainnav" class="nav">
  </div>
    <div id="main">
      <div id="pagepath" class="noprint">
  <a class="pathentry first" title="View WikiStart" href="/wiki/public/wiki">wiki:</a><a class="pathentry" href="/wiki/public/wiki/cs222-2018-fall-project4" title="View cs222-2018-fall-project4">cs222-2018-fall-project4</a>
</div>
      <div id="ctxtnav" class="nav">
        <h2>Context Navigation</h2>
        <ul>
          <li class="first"><a href="/wiki/public/wiki/WikiStart">Start Page</a></li><li><a href="/wiki/public/wiki/TitleIndex">Index</a></li><li class="last"><a href="/wiki/public/wiki/cs222-2018-fall-project4?action=history">History</a></li>
        </ul>
        <hr />
      </div>
    <div id="content" class="wiki">
      <div class="wikipage searchable">
        
          <div id="wikipage" class="trac-content"><div style="background-color:rgb(237,222,222)" class="wikipage"><p>
</p><div class="wiki-toc">
<ol>
  <li>
    <a href="#Project4:ImplementingaQueryEnginewiththeExtensionoftheRelationManager">Project 4: Implementing a Query Engine with the Extension of the â€¦</a>
    <ol>
      <li>
        <a href="#Introduction">Introduction</a>
      </li>
    </ol>
  </li>
  <li>
    <a href="#Part4.1:RelationManagerExtensions">Part 4.1: RelationManager Extensions</a>
    <ol>
      <li>
        <a href="#RelationManager">RelationManager</a>
        <ol>
          <li>
            <a href="#RCcreateIndexconststringtableNameconststringattributeName">RC createIndex(const string &amp;tableName, const string &amp;attributeName)</a>
          </li>
          <li>
            <a href="#RCdestroyIndexconststringtableNameconststringattributeName">RC destroyIndex(const string &amp;tableName, const string &amp;attributeName)</a>
          </li>
          <li>
            <a href="#RCindexScanconststringtableNameconststringattributeNameconstvoidlowKeyconstvoidhighKeyboollowKeyInclusiveboolhighKeyInclusiveRM_IndexScanIteratorrm_IndexScanIterator">RC indexScan(const string &amp;tableName, const string &amp;attributeName, â€¦</a>
          </li>
        </ol>
      </li>
      <li>
        <a href="#RM_IndexScanIterator">RM_IndexScanIterator</a>
        <ol>
          <li>
            <a href="#RCgetNextEntryRIDridvoidkey">RC getNextEntry(RID &amp;rid, void *key)</a>
          </li>
          <li>
            <a href="#RCclose">RC close()</a>
          </li>
        </ol>
      </li>
    </ol>
  </li>
  <li>
    <a href="#Part4.2:QueryEngine">Part 4.2: Query Engine</a>
    <ol>
      <li>
        <a href="#IteratorInterface">Iterator Interface</a>
        <ol>
          <li>
            <a href="#virtualRCgetNextTuplevoiddata">virtual RC getNextTuple(void *data)</a>
          </li>
          <li>
            <a href="#virtualvoidgetAttributesvectorAttributeattrs">virtual void getAttributes(vector&lt;Attribute&gt; &amp;attrs)</a>
          </li>
        </ol>
      </li>
      <li>
        <a href="#FilterInterface">Filter Interface</a>
      </li>
      <li>
        <a href="#ProjectInterface">Project Interface</a>
      </li>
      <li>
        <a href="#BlockNested-LoopJoinInterface">Block Nested-Loop Join Interface</a>
      </li>
      <li>
        <a href="#IndexNested-LoopJoinInterface">Index Nested-Loop Join Interface</a>
      </li>
      <li>
        <a href="#GraceHashJoinInterface">Grace Hash Join Interface</a>
      </li>
      <li>
        <a href="#AggregateInterface">Aggregate Interface</a>
      </li>
      <li>
        <a href="#ImportantNote">Important Note</a>
      </li>
      <li>
        <a href="#AnExample">An Example</a>
      </li>
      <li>
        <a href="#CommandLineInterfaceInterpreter">Command Line Interface Interpreter</a>
      </li>
      <li>
        <a href="#Appendix">Appendix</a>
      </li>
      <li>
        <a href="#Testing">Testing</a>
      </li>
      <li>
        <a href="#SubmissionInstructions">Submission Instructions</a>
      </li>
      <li>
        <a href="#GradingRubrics">Grading Rubrics</a>
      </li>
      <li>
        <a href="#QA">Q &amp; A</a>
      </li>
    </ol>
  </li>
</ol>
</div><p>
</p>
<h1 id="Project4:ImplementingaQueryEnginewiththeExtensionoftheRelationManager">Project 4: Implementing a Query Engine with the Extension of the Relation Manager</h1>
<ul><li><strong> Deadline: Friday, Dec 7, 2018 at 11:45 pm, on Github.</strong>
</li><li><strong> Full Credit: 100 points </strong>
</li><li><strong> Maximum Extra Credit: 15 points. </strong><br />
</li><li><strong> As in Projects 2 and 3, you should work with your original team member for this Project. </strong>
</li></ul><h2 id="Introduction">Introduction</h2>
<p>
In this project, you will first extend the RelationManager (RM) component that you implemented for project 2 so that the RM layer can orchestrate both the RecordBasedFileManager (RBF) and IndexManager (IX) layers when tuple-level operations happen, and the RM layer will also be managing the catalog information related to indices at this level. After the RM layer extension, you will implement a QueryEngine (QE) component. The QE component provides classes and methods for answering SQL queries. For simplicity, you only need to implement several basic relational operators. All operators are iterator-based. To give you a jumpstart, we've implemented two wrapper operators on top of the RM layer that provide file and index scanning. See the <a class="wiki" href="/wiki/public/wiki/cs222-2018-fall-project4#Appendix">Appendix</a> for more details.<br />
</p>
<p>
You can pull again from our <a class="ext-link" href="https://github.com/UCI-Chenli-teaching/cs222-fall18"><span class="icon">â€‹</span>github repo</a> to get the project template. 
See also the test cases included in the codebase for in-depth examples of how the operators are used.
</p>
<p>
<br />
</p>
<h1 id="Part4.1:RelationManagerExtensions">Part 4.1: RelationManager Extensions</h1>
<h2 id="RelationManager">RelationManager</h2>
<p>
All of the methods that you implemented for Project 2 should now be extended to coordinate data files plus any associated indices of the data files. For example, if you insert a tuple into a table using RelationManager::insertTuple(), the tuple should be inserted into the table (via the RBF layer) and each corresponding entry should be inserted into each associated index of the table (via the IX layer). Also, if you delete a table using RelationManager::deleteTable(), all associated indices should be deleted, too. This applies both to catalog entries that record what's what and to the file artifacts themselves.  The RelationManager class, in addition to enforcing the coordination semantics between data files and the indices in your existing methods, will also include the following newly-added index-related methods. These methods can all be implemented by simply delegating their work to the underlying IX layer that you built in Project 3. (This part of the project is largely a big wrapper. :-))
</p>
<pre class="wiki">class RelationManager
{
public:
  ...
  RC createIndex(const string &amp;tableName, const string &amp;attributeName);

  RC destroyIndex(const string &amp;tableName, const string &amp;attributeName);

  // indexScan returns an iterator to allow the caller to go through qualified entries in index
  RC indexScan(const string &amp;tableName,
                        const string &amp;attributeName,
                        const void *lowKey,
                        const void *highKey,
                        bool lowKeyInclusive,
                        bool highKeyInclusive,
                        RM_IndexScanIterator &amp;rm_IndexScanIterator
       );
  ...
}
</pre><h3 id="RCcreateIndexconststringtableNameconststringattributeName">RC createIndex(const string &amp;tableName, const string &amp;attributeName)</h3>
<p>
This method creates an index on a given attribute of a given table.  (It should also reflect its existence in the catalogs.)
</p>
<h3 id="RCdestroyIndexconststringtableNameconststringattributeName">RC destroyIndex(const string &amp;tableName, const string &amp;attributeName)</h3>
<p>
This method destroys an index on a given attribute of a given table.  (It should also reflect its non-existence in the catalogs.)
</p>
<h3 id="RCindexScanconststringtableNameconststringattributeNameconstvoidlowKeyconstvoidhighKeyboollowKeyInclusiveboolhighKeyInclusiveRM_IndexScanIteratorrm_IndexScanIterator">RC indexScan(const string &amp;tableName, const string &amp;attributeName, const void *lowKey, const void *highKey, bool lowKeyInclusive, bool highKeyInclusive, RM_IndexScanIterator &amp;rm_IndexScanIterator)</h3>
<p>
This method should initialize a condition-based scan over the entries in the open index on the given attribute of the given table. If the scan initiation method is successful, a RM_IndexScanIterator object called rm_IndexScanIterator is returned. (Please see the RM_IndexScanIterator class below.) Once underway, by calling RM_IndexScanIterator::getNextEntry(), the iterator should produce the entries of all records whose indexed attribute key falls into the range specified by the lowKey, highKey, and inclusive flags. If lowKey is NULL, it can be interpreted as -infinity. If highKey is NULL, it can be interpreted as +infinity. The format of the parameter lowKey and highKey is the same as the format of the key in IndexManager::insertEntry(). 
</p>
<h2 id="RM_IndexScanIterator">RM_IndexScanIterator</h2>
<pre class="wiki">class RM_IndexScanIterator {
 public:
  RM_IndexScanIterator();  	// Constructor
  ~RM_IndexScanIterator(); 	// Destructor

  // "key" follows the same format as in IndexManager::insertEntry()
  RC getNextEntry(RID &amp;rid, void *key);  	// Get next matching entry
  RC close();             			// Terminate index scan
};
</pre><h3 id="RCgetNextEntryRIDridvoidkey">RC getNextEntry(RID &amp;rid, void *key)</h3>
<p>
This method should set its output parameters rid and key to be the RID and key, respectively, of the next record in the index scan. This method should return RM_EOF if there are no index entries left satisfying the scan condition. You may assume that RM component clients will not close the corresponding open index while a scan is underway.
</p>
<h3 id="RCclose">RC close()</h3>
<p>
This method should terminate the index scan.
</p>
<p>
<br />
<br />
</p>
<h1 id="Part4.2:QueryEngine">Part 4.2: Query Engine</h1>
<h2 id="IteratorInterface">Iterator Interface</h2>
<p>
All of the operators that you will implement in this part inherit from the following <strong>Iterator</strong> interface.
</p>
<pre class="wiki">class Iterator {
    // All the relational operators and access methods are iterators
    // This class is the super class of all the following operator classes
    public:
        virtual RC getNextTuple(void *data) = 0;
        // For each attribute in vector&lt;Attribute&gt;, name it rel.attr
        virtual void getAttributes(vector&lt;Attribute&gt; &amp;attrs) const = 0;
        virtual ~Iterator() {};
};
</pre><h3 id="virtualRCgetNextTuplevoiddata">virtual RC getNextTuple(void *data)</h3>
<p>
This method should set the output parameter <strong>data</strong> of the next record. The format of the <strong>data</strong> parameter, which refers to the next tuple of the operator's output, is the same as that used in previous projects. Also, null-indicators for the given attributes are always placed at the beginning of <strong>data</strong>. That is, the tuple value is a sequence of binary attribute values in which null-indicators are placed first and then each value is represented as follows: (1) For INT and REAL: use 4 bytes; (2) For VARCHAR: use 4 bytes for the length followed by the characters.
</p>
<h3 id="virtualvoidgetAttributesvectorAttributeattrs">virtual void getAttributes(vector&lt;Attribute&gt; &amp;attrs)</h3>
<p>
This method returns a vector of attributes in the intermediate relation resulted from this iterator.  That is, while the previous method returns the tuples from the operator, this method makes the associated schema information for the returned tuple stream available in the query plan. The names of the attributes in vector&lt;Attribute&gt; should be of the form relation.attribute to clearly specify the relation from which each attribute comes.
</p>
<h2 id="FilterInterface">Filter Interface</h2>
<pre class="wiki">class Filter : public Iterator {
    // Filter operator
    public:
        Filter(Iterator *input,                         // Iterator of input R
               const Condition &amp;condition               // Selection condition
        );
        ~Filter();

        RC getNextTuple(void *data);
        // For attribute in vector&lt;Attribute&gt;, name it as rel.attr
        void getAttributes(vector&lt;Attribute&gt; &amp;attrs) const;
};
</pre><p>
Using this iterator, you can do a selection query such as "SELECT * FROM EMP WHERE sal &gt; 100000". 
</p>
<p>
This filter class is initialized by an input iterator and a selection condition. It filters the tuples from the input iterator by applying the filter predicate <strong>condition</strong> on them. For simplicity, we assume this filter only has a single selection condition. The schema of the returned tuples should be the same as the input tuples from the iterator.
</p>
<h2 id="ProjectInterface">Project Interface</h2>
<pre class="wiki">class Project : public Iterator {
    // Projection operator
    public:
        Project(Iterator *input,                            // Iterator of input R
                const vector&lt;string&gt; &amp;attrNames);           // vector containing attribute names
        ~Project();

        RC getNextTuple(void *data);
        // For attribute in vector&lt;Attribute&gt;, name it as rel.attr
        void getAttributes(vector&lt;Attribute&gt; &amp;attrs) const;
};
</pre><p>
This project class takes an iterator and a vector of attribute names as input. It projects out the values of the attributes in the <strong>attrNames</strong>. The schema of the returned tuples should be the attributes in attrNames, in the order of attributes in the vector.
</p>
<h2 id="BlockNested-LoopJoinInterface">Block Nested-Loop Join Interface</h2>
<ul><li><strong> This is mandatory.  </strong>
</li></ul><pre class="wiki">class BNLJoin : public Iterator {
    // Block nested-loop join operator
    public:
        BNLJoin(Iterator *leftIn,                              // Iterator of input R
               TableScan *rightIn,                             // TableScan Iterator of input S
               const Condition &amp;condition,                     // Join condition
               const unsigned numPages                         // Number of pages can be loaded into memory, i.e., memory block size (decided by the optimizer)
        );
        ~BNLJoin();

        RC getNextTuple(void *data);
        // For attribute in vector&lt;Attribute&gt;, name it as rel.attr
        void getAttributes(vector&lt;Attribute&gt; &amp;attrs) const;
};
</pre><p>
The BNLJoin takes two iterators as input. The <strong>leftIn</strong> iterator works as the outer relation and the <strong>rightIn</strong> iterator is the inner relation. The <strong>rightIn</strong> is an object of the TableScan Iterator. We have already implemented the TableScan class for you, which is a wrapper on  RM_ScanIterator. The returned schema should be the attributes of tuples from leftIn concatenated with the attributes of tuples from rightIn. You don't need to remove any duplicate attributes. Note that <strong>numPages</strong> is the number of outer (left) pages that the algorithm can load into memory at once. In other words, <strong>numPages</strong> is equal to the memory block size (measured in pages) that your algorithm should utilize to make the number of loops through the inner (right) table smaller than a simple tuple-oriented join's would be (by a factor of <strong>numPages</strong>). That is, numPages is the number of buffers that can be used to as a read buffer and hash buckets. However, to make it simple, you can use these buffer pages to read records from R. You can construct an another separate in-memory hash table (e.g., std::map) to keep the records in the numPages buffer. This means std::map will take care of two things: loading tuples and hashing them. <strong>Make sure that the total number of bytes of the loaded tuples in one round does not exceed "numPages * pageSize".</strong>  You can also assume that you have one page buffer to read a page from the inner relation <strong>rightIn</strong> and one page output buffer to keep the results.
</p>
<h2 id="IndexNested-LoopJoinInterface">Index Nested-Loop Join Interface</h2>
<pre class="wiki">class INLJoin : public Iterator {
    // Index Nested-Loop join operator
    public:
        INLJoin(Iterator *leftIn,                               // Iterator of input R
                IndexScan *rightIn,                             // IndexScan Iterator of input S
                const Condition &amp;condition                      // Join condition
        );

        ~INLJoin();

        RC getNextTuple(void *data);
        // For attribute in vector&lt;Attribute&gt;, name it as rel.attr
        void getAttributes(vector&lt;Attribute&gt; &amp;attrs) const;
};
</pre><p>
The INLJoin iterator takes two iterators as input. The <strong>leftIn</strong> iterator works as the outer relation, and the <strong>rightIn</strong> iterator is the inner relation. The <strong>rightIn</strong> is an object of IndexScan Iterator. Again, we have already implemented the IndexScan class for you, which is a wrapper on RM_IndexScanIterator. The returned schema should be the attributes of tuples from leftIn concatenated with the attributes of tuples from rightIn. You don't need to remove any duplicate attributes.
</p>
<h2 id="GraceHashJoinInterface">Grace Hash Join Interface</h2>
<ul><li><strong> Optional: 10 extra-credit points for <em>everyone</em>. </strong>
<pre class="wiki">class GHJoin : public Iterator {
    // Grace hash join operator
    public:
        GHJoin(Iterator *leftIn,                            // Iterator of input R
               Iterator *rightIn,                           // Iterator of input S
               const Condition &amp;condition,                  // Join condition (CompOp is always EQ)
               const unsigned numPartitions                 // Number of partitions for each relation (decided by the optimizer)
        );
        ~GHJoin();

        RC getNextTuple(void *data);
        // For attribute in vector&lt;Attribute&gt;, name it as rel.attr
        void getAttributes(vector&lt;Attribute&gt; &amp;attrs) const;
};
</pre></li></ul><p>
Using this iterator you can do a join query such as "SELECT * FROM EMP, DEPT WHERE EMP.DID = DEPT.DID".
</p>
<p>
The GHJoin takes two iterators as input. It uses <strong>leftIn</strong> to iterate over the outer relation and the <strong>rightIn</strong> to iterate over the inner relation. Following is a sketch of how to implement this operator:
</p>
<blockquote>
<p>
1- In the partitioning phase, create <strong>numPartitions</strong> partitions for each relation where each partition is an rbfm file. The name of the outer relation partitions must start with the word "left" while the name of the inner relation partitions must start with the word "right". In order to avoid conflicts in the file names (in the case of multiple GHJoins in the query tree) you will have to add a suffix that uniquely identify your partitions. For example, you can have something like left_join1_XX and right_join1_XX for the first join and left_join2_XX and right_join2_XX for the second join. <strong>Note</strong>: It is NOT acceptable to load the entire relation into memory while building the partitions -- you should assume that a query optimizer has chosen the number of partitions based on the amount of memory it has decided to allow this operator to use.
</p>
</blockquote>
<p>
   
</p>
<blockquote>
<p>
2- In the probing phase, load a partition of either R or S (in fact you might want to load the smaller partition<sup>*</sup>) into memory, then build an in-memory hash table for such partition. Next, probe the corresponding partition from the other relation for matching tuples.
</p>
</blockquote>
<p>
   
</p>
<blockquote>
<p>
3- The output will be the join-tuples that must be passed to the next operator. The schema of these join-tuples should be the attributes of tuples from leftIn concatenated with the attributes of tuples from rightIn. You don't need to remove any duplicate attributes.
</p>
</blockquote>
<p>
<sup>*</sup> Note that if you load the smaller partition (to compare the sizes of the partitions you can use <strong>fileHandle.getNumberOfPages()</strong>) you may need to rearrange the output attributes if S becomes the left relation. This is NOT a requirement but a closer implementation to what happens in practice  :-).  
</p>
<h2 id="AggregateInterface">Aggregate Interface</h2>
<ul><li><strong>Basic aggregation is Mandatory. </strong>
</li><li><strong>Group-based hash aggregation is Optional for everyone. You will get 5 extra-credit points for doing so.</strong>
</li></ul><pre class="wiki">class Aggregate : public Iterator {
    // Aggregation operator
    public:
        // Mandatory for everyone
        // Basic aggregation
        Aggregate(Iterator *input,                              // Iterator of input R
                  Attribute aggAttr,                            // The attribute over which we are computing an aggregate
                  AggregateOp op                                // Aggregate operation
        );

        // Optional for everyone. 5 extra-credit points
        // Group-based hash aggregation
        Aggregate(Iterator *input,                              // Iterator of input R
                  Attribute aggAttr,                            // The attribute over which we are computing an aggregate
                  Attribute groupAttr,                          // The attribute over which we are grouping the tuples
                  AggregateOp op                                // Aggregate operation
        );

        ~Aggregate();

        RC getNextTuple(void *data);
        // Please name the output attribute as aggregateOp(aggAttr)
        // E.g. Relation=rel, attribute=attr, aggregateOp=MAX
        // output attrname = "MAX(rel.attr)"
        void getAttributes(vector&lt;Attribute&gt; &amp;attrs) const;
};
</pre><p>
<strong>Basic aggregation:</strong> Using the basic aggregation operator, you can execute a query such as: "SELECT MAX(sal) FROM EMP". <br />
The basic aggregate method takes an input iterator, an aggregated attribute, and an aggregate function (MIN, MAX, SUM, AVG, COUNT) as the arguments. You can assume we do the aggregation on a numeric attribute (INT or REAL). The returned value is just a single real value (4 bytes), even for the COUNT function. The schema of the (single) returned tuple should be "AggregateOp(relation.attribute)", such as "MAX(emp.sal)". Also,  null-indicators always needs to be placed at the beginning of a tuple.
</p>
<p>
<strong>Group-based hash aggregation:</strong> Using the group-based hash aggregation operator, you can execute a query such as: "SELECT city, MAX(sal) FROM EMP GROUP BY city". <br />
To implement the <em>group-by</em> feature, you need to implement the group-based hash aggregation where we add one more argument to the argument list: <strong>groupAttr</strong>, which is the group-by attribute. Unlike Grace Hash Join, you are not required to implement hash-partitioned aggregation using partitions on disk. You can assume that all of the groups' aggregation values will fit in a hash table in memory while the operation is executing. (E.g., think group by age or group by state -- where the number of groups is reasonable.) Each returned tuple should include the group-by attribute value followed by the aggregation value. The group-by attribute can be INT, REAL, or VARCHAR. The aggregated attribute can be INT or REAL. The schema of the returned tuples should be the group-by attribute and the aggregation attribute, such as "emp.city MAX(emp.sal)". Null-indicators always needs to be placed at the beginning of each tuple. <strong>5 extra-credit points</strong>
</p>
<h2 id="ImportantNote">Important Note</h2>
<p>
You must make sure that all operators which create temporary rbfm files to clean up after themselves. That is, such files must be deleted when the operator is closed. 
</p>
<h2 id="AnExample">An Example</h2>
<p>
Here is an example showing how to assemble the operators to form query plans.  Example: "SELECT Employee.name, Employee.age, Employee.DeptID, Department.Name FROM  Employee JOIN Department ON Employee.DeptID = Department.ID WHERE Employee.salary &gt; 50000". We are assuming for this example that the optimizer has picked the Grace Hash Join algorithm to execute the join. 
</p>
<pre class="wiki">/****** ****** ****** ****** ******
 *    TABLE SCANS
 ****** ****** ****** ****** ******/

TableScan *emp_ts = new TableScan(rm, "Employee");
TableScan *dept_ts = new TableScan(rm, "Department");

/****** ****** ****** ****** ******
 *    FILTER Employee Table
 ****** ****** ****** ****** ******/

Condition cond_f;
cond_f.lhsAttr = "Employee.Salary";
cond_f.op = GT_OP;
cond_f.bRhsIsAttr = false;
Value value;
value.type = TypeInt;
value.data = malloc(bufsize);
*(int *)value.data = 50000;
cond_f.rhsValue = value;

Filter *filter = new Filter(emp_ts, cond_f);

/****** ****** ****** ****** ******
 *    PROJECT Employee Table
 ****** ****** ****** ****** ******/

vector&lt;string&gt; attrNames;
attrNames.push_back("Employee.name");
attrNames.push_back("Employee.age");
attrNames.push_back("Employee.DeptID");

Project project(filter, attrNames);

/****** ****** ****** ****** ******
 *   GRACE HASH JOIN Employee with Dept
 ****** ****** ****** ****** ******/

Condition cond_j;
cond_j.lhsAttr = "Employee.DeptID";
cond_j.op = EQ_OP;
cond_j.bRhsIsAttr = true;
cond_j.rhsAttr = "Department.ID";

GHJoin *ghJoin = new GHJoin(project, dept_ts, cond_j, 100);



void *data = malloc(bufsize);
while(ghJoin.getNextTuple(data) != QE_EOF)
{
  printAttributes(data);
}
</pre><h2 id="CommandLineInterfaceInterpreter">Command Line Interface Interpreter</h2>
<p>
Instead of having to manually assemble the operators to form query plans, as shown in the above example, we are also providing you with a Command Line Interface (CLI) that takes a SQL-like command and executes that command. This will hopefully provide a better, more flexible test environment than the manual approach presented above (e.g., assembling query plans manually, running them, and even debugging them). The CLI runs in interactive mode so that you can type commands and see their results interactively. To get more information about the CLI, please visit  <a class="wiki" href="/wiki/public/wiki/cs222-2018-fall-command-line-interface">this page</a>. Note that the CLI is provided for your convenience. We will not be using the CLI to test your code.
</p>
<p>
<strong>Important Notes:</strong> 
</p>
<ol><li>In order to run the CLI on Ubuntu you might need to install this library <strong>libreadline-dev</strong>. You can run the following command to install it:
<pre class="wiki">sudo apt-get install libreadline-dev 
</pre></li></ol><ol start="2"><li>CLI uses C++11 features. You might need to use g++-4.8 to compile CLI. Please refer to <a class="ext-link" href="http://ubuntuhandbook.org/index.php/2013/08/install-gcc-4-8-via-ppa-in-ubuntu-12-04-13-04/"><span class="icon">â€‹</span>this page</a> to install GCC 4.8 on Ubuntu. You can ignore this step if you already have a GCC with version &gt;= 4.8
</li></ol><h2 id="Appendix">Appendix</h2>
<p>
Below we list the APIs for the three classes used in the operators. For more detailed implementation information, please refer to the <strong>qe.h</strong> header file in the code base. Note that in the TableScan and IndexScan classes, the argument <strong>alias</strong> is used to rename the input relation. In the case of self-joins, at least one of the uses of the relations must be renamed to differentiate the two from each other in terms of attribute naming.
</p>
<pre class="wiki">struct Condition {
    string lhsAttr;         // left-hand side attribute                     
    CompOp  op;             // comparison operator                          
    bool    bRhsIsAttr;     // TRUE if right-hand side is an attribute and not a value; FALSE, otherwise
    string  rhsAttr;        // right-hand side attribute if bRhsIsAttr = TRUE
    Value   rhsValue;       // right-hand side value if bRhsIsAttr = FALSE
};
</pre><pre class="wiki">class TableScan : public Iterator
{
TableScan(RelationManager &amp;rm, const string &amp;tableName, const char *alias = NULL);  // constructor
void setIterator();                                                         // Start a new iterator
RC getNextTuple(void *data);                                                // Return the next tuple from the iterator
void getAttributes(vector&lt;Attribute&gt; &amp;attrs) const;                         // Return the attributes from this iterator
~TableScan();                                                               // destructor
};
</pre><pre class="wiki">class IndexScan : public Iterator
{
IndexScan(RelationManager &amp;rm, const string &amp;tableName, const string &amp;attrName, const char *alias = NULL); // constructor
void setIterator(void* lowKey, void* highKey, bool lowKeyInclusive, bool highKeyInclusive); // Start a new iterator given the new compOp and value
RC getNextTuple(void *data);                                                                                  // Return the next tuple from the iterator
void getAttributes(vector&lt;Attribute&gt; &amp;attrs) const;                                                           // Return the attributes from this iterator
~IndexScan();                                                                                                 // destructor
};
</pre><h2 id="Testing">Testing</h2>
<p>
Please use the provided test files included in the codebase to test your code. Note that this file will be used to grade your project partially since we also have our own private test cases. This is by no means an exhaustive test suite. Please feel free to add more cases to this, and test your code thoroughly. The test code includes provisional points for each test case. The points are subject to change if needed.
</p>
<h2 id="SubmissionInstructions">Submission Instructions</h2>
<p>
The following are requirements on your submission. Points may be deducted if they are not followed.
</p>
<ul><li>Write a report to briefly describe the design and implementation of your query engine module.
</li><li>You need to submit the source code under the "rbf" ,"rm" ,"ix", "qe", and data folder. Make sure you do a "make clean" first, and do NOT include any useless files (such as binary files and data files). Your makefile should make sure the files <em>qetest_XX.cc<strong> compile and run properly. We will use our own </strong></em><strong>qetest_XX.cc</strong> files to test your module.
</li></ul><p>
 
</p>
<ul><li>Please organize your project in the following directory hierarchy: master / {rbf, rm, ix, qe, data, makefile.inc, readme.txt, project4-report} where rbf, rm, ix, and qe folders include your source code and the makefile.
</li><li>To test whether your code is structured properly, you can make a zip file from the master (by compressing your local directory or downloading from Github). Put  <a class="attachment" href="/wiki/public/attachment/wiki/cs222-2018-fall-project4/test.sh" title="Attachment 'test.sh' in cs222-2018-fall-project4">this script</a><a class="trac-rawlink" href="/wiki/public/raw-attachment/wiki/cs222-2018-fall-project4/test.sh" title="Download">â€‹</a>â€‹ and the zip file under the same directory. Run it to verify that your project can be properly unzipped and tested (use your own makefile.inc and the ixtest*.cc when you are testing the script). If the script doesn't work correctly, it's likely that your folder organization doesn't meet the above requirements. Our grading will be done by automatically done by running the script. The usage of the script is:
<pre class="wiki">    # Suppose you download your project from Github to your local laptop: cs222-fall-team-xx-master.zip, 
    # run the following command will unzip and test your code automatically: (if you see directory structure is not correct message, make sure to fix it.) 

    ./test.sh ''cs222-fall18-team-xx-master''
</pre></li></ul><h2 id="GradingRubrics">Grading Rubrics</h2>
<p>
The grading rubrics is at <a class="wiki" href="/wiki/public/wiki/cs222-2018-fall-project4-grading">this page</a>
</p>
<h2 id="QA">Q &amp; A</h2>
<ul><li><strong>Q1</strong>: For the grace hash-join and block nested loop join, can I use a std::map() as an in-memory table? <br /> 
<strong>A1</strong>: Yes. You can.
</li></ul><blockquote>
<p>
<strong>Q2</strong>: For the block-nested loop join, we are supposed to use numPages buffer to read tuples from the leftIn relation. How to use the memory based on this parameter? <br />
<strong>A2</strong>: Suppose we do a BNLP for two inputs R and S, where R is the left child.   To simplify the implementation, it is acceptable to read "numPages" pages from R, then build an in-memory hash table (with additional memory) for these records.  In addition, it is also acceptable to use the getNext() API of R to read enough records to fill in *one* page, then immediately add them to the in-memory hash table.  Then we continue the process until we have read enough records for numPages pages (one page at a time).  Since the records from S are pipelined, you can join a record from S.getNext() immediately using the hash table of R.  You are required to have an output buffer.  You pause the join process whenever the output buffer is full.
</p>
</blockquote>
<ul><li><strong>Q3</strong>: What types of joins do we need to support? <br /> 
<strong>A3</strong>: Based on the scope of this project, we only need you to implement equi-join on single join attribute. However, you do need to support the case that multiple records share the same join key value.
</li></ul><ul><li><strong>Q4</strong>: Do I need to read a page at a time from the right table of BNL join, since <a class="forbidden wiki" title="no permission to view this wiki page">TableScan</a> only supports a tuple-based API? <br /> 
<strong>A4</strong>: For simplicity, you can read a tuple from the right table at a time and generate join tuple directly.
</li></ul><ul><li><strong>Q5</strong>: How to handle NULL values in Join,Aggregation, and <a class="forbidden wiki" title="no permission to view this wiki page">GroupBy</a>? <br /> 
<strong>A5</strong>: Based on the scope of this project, You do not to support NULL values in these operators. However, you should make sure you index does not contain NULL keys (they should be filtered out).
</li></ul></div></div>
          
          <div class="trac-modifiedby">
            <span><a href="/wiki/public/wiki/cs222-2018-fall-project4?action=diff&amp;version=7" title="Version 7 by cluo8">Last modified</a> <a class="timeline" href="/wiki/public/timeline?from=2018-12-04T11%3A37%3A23-08%3A00&amp;precision=second" title="See timeline at Dec 4, 2018 11:37:23 AM">2 months ago</a></span>
            <span class="trac-print">Last modified on Dec 4, 2018 11:37:23 AM</span>
          </div>
        
        
      </div>
      
    <div id="attachments">
        <h3 class="foldable">Attachments <span class="trac-count">(1)</span></h3>
        <div>
          <ul>
              <li>
    <a href="/wiki/public/attachment/wiki/cs222-2018-fall-project4/test.sh" title="View attachment">test.sh</a><a href="/wiki/public/raw-attachment/wiki/cs222-2018-fall-project4/test.sh" class="trac-rawlink" title="Download">â€‹</a>
       (<span title="756 bytes">756 bytes</span>) -
      added by <em>cluo8</em> <a class="timeline" href="/wiki/public/timeline?from=2018-11-20T08%3A56%3A43-08%3A00&amp;precision=second" title="See timeline at Nov 20, 2018 8:56:43 AM">2 months ago</a>.
              </li>
          </ul>
          <p>
            Download all attachments as: <a rel="nofollow" href="/wiki/public/zip-attachment/wiki/cs222-2018-fall-project4/">.zip</a>
          </p>
        </div>
    </div>

    </div>
    <div id="altlinks">
      <h3>Download in other formats:</h3>
      <ul>
        <li class="last first">
          <a rel="nofollow" href="/wiki/public/wiki/cs222-2018-fall-project4?format=txt">Plain Text</a>
        </li>
      </ul>
    </div>
    </div>
    <div id="footer" lang="en" xml:lang="en"><hr />
      <a id="tracpowered" href="http://trac.edgewall.org/"><img src="/wiki/public/chrome/common/trac_logo_mini.png" height="30" width="107" alt="Trac Powered" /></a>
      <p class="left">Powered by <a href="/wiki/public/about"><strong>Trac 1.0.13</strong></a><br />
        By <a href="http://www.edgewall.org/">Edgewall Software</a>.</p>
      <p class="right">Visit the Trac open source project at<br /><a href="http://trac.edgewall.org/">http://trac.edgewall.org/</a></p>
    </div>
  </body>
</html>Mis_redirected¢DtypeEvalueôIhttp_code¢DtypeEvalueÈQdownload_complete¢DtypeEvalueõ