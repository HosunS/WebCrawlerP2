¦Ifinal_url¢DtypeEvaluexBhttps://www.ics.uci.edu/~thornton/ics45c/Notes/MoreAboutFunctions/Lhttp_headers¢DtypeEvalue‡¢Ak¢DtypeEvalueNContent-LengthAv¢DtypeEvalueE22788¢Ak¢DtypeEvalueMAccept-RangesAv¢DtypeEvalueEbytes¢Ak¢DtypeEvalueFServerAv¢DtypeEvalueX4Apache/2.4.6 (CentOS) OpenSSL/1.0.2k-fips SVN/1.7.14¢Ak¢DtypeEvalueMLast-ModifiedAv¢DtypeEvalueXMon, 14 Jan 2019 23:24:46 GMT¢Ak¢DtypeEvalueDETagAv¢DtypeEvalueT"5904-57f7359ac8b80"¢Ak¢DtypeEvalueDDateAv¢DtypeEvalueXThu, 31 Jan 2019 10:08:06 GMT¢Ak¢DtypeEvalueLContent-TypeAv¢DtypeEvalueXtext/html; charset=UTF-8Kraw_content¢DtypeEvalueYY<?xml version="1.0" encoding="iso-8859-1"?>
<!DOCTYPE html PUBLIC
 "-//W3C//DTD XHTML 1.1//EN"
 "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">

<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en">

<head>
<meta http-equiv="content-type" content="text/html; charset=iso-8859-1" />
<link rel="stylesheet" href="../../course.css" type="text/css" />

<title>ICS 45C Winter 2019, Notes and Examples: More About Functions</title>

</head>

<body>

<div class="navbar">

<p>
ICS 45C Winter 2019 |
<a href="../../index.html">News</a> |
<a href="../../CourseReference.html">Course Reference</a> |
<a href="../../Schedule.html">Schedule</a> |
<a href="../../ProjectGuide">Project Guide</a> |
<a href="../../Notes">Notes and Examples</a> |
<a href="http://www.ics.uci.edu/~thornton/">About Alex</a>
</p>

<hr />

</div>

<div class="header">

<p>ICS 45C Winter 2019<br />
   Notes and Examples: More About Functions</p>

</div>

<div class="section">

<hr />

<p class="title">Pass-by-value parameters</p>

<p>We've seen previously that functions in C++ can accept <i>parameters</i>, which are information that is passed into them from callers, as a way of configuring what the called function will do.  From a terminology perspective, we say that the called function accepts parameters, and that the calling function passes <i>arguments</i>.  Arguments are matched up to parameters by the order in which they're specified &mdash; the first argument matches the first parameter, the second argument matches the second parameter, and so on &mdash; and a function call is legal whenever the types of all arguments are compatible with the types of all parameters.  (What it means for them to be "compatible" is a concept that's deeper than it sounds, but we won't focus on that for the time being; we'll come back to that issue a little later.)</p>

<p>Unless you specify otherwise, all parameters in C++ are <i>pass-by-value</i> parameters.  The term <i>pass-by-value</i> indicates that what is passed into a function are the <i>values</i> of the arguments specified by the caller, which implies that these values are copied into the function; the function only has access to the copies, so any modifications made to those copies have no effect on the originals.</p>

<p>Consider this short C++ program as an example:</p>

<blockquote><pre>
void foo(int x)
{
    x++;
    std::cout &lt;&lt; x &lt;&lt; std::endl;
}

int main()
{
    int i = 3;
    foo(i);
    std::cout &lt;&lt; i &lt;&lt; std::endl;
    return 0;
}
</pre></blockquote>

<p>First, a copy of <b>i</b>'s value is passed into <b>foo()</b>, so <b>foo()</b>'s <b>x</b> parameter has the value 3.  Within the function, <b>x</b> is incremented and then printed to the standard output, so we'll see the value <b>4</b> printed first.  After that, <b>foo()</b> returns.  As with any other function, when <b>foo()</b> ends, its parameters are destroyed, so <b>x</b> ceases to exist.  We pick up execution back in <b>main()</b> and print the value of <b>i</b>, and this is the important part of the example.  <i>Did the value of <b>i</b> change when <b>foo()</b> changed its parameter <b>x</b>?</i>  The answer is <i>no</i>, because <b>foo()</b>'s <b>x</b> was a copy of the value of <b>i</b>; modifying <b>x</b> had no effect on <b>i</b>, so <b>3</b> is printed at this point, and then the program ends.</p>

<p class="subtitle">How pass-by-value parameters are implemented</p>

<p>We've seen previously that an activation record is stored on the run-time stack whenever a function is called, and that function's parameters are part of what's stored in that activation record.  Pass-by-value parameters have their values copied into the appropriate locations within the activation record during the process of calling the function.  Since each parameter has a type, it also has a known size at compile time, which allows the compiler to determine precisely where within the activation record each parameter will be stored.  Wherever the function needs to access those parameters, the compiler emits code that finds their values in the appropriate offset into the activation record (i.e., at a known distance before or after where the frame pointer points).</p>

<p>This may seem like a fairly unimportant detail, but there are three things that are important to understand about it.</p>

<p>First of all, pass-by-value parameters allow their corresponding arguments to be either lvalues or rvalues.  For example, in the example above, if we replaced the call to <b>foo()</b> in the <b>main()</b> function with this:</p>

<blockquote><pre>
foo(3);
</pre></blockquote>

<p>or with this instead:</p>

<blockquote><pre>
int j = 4;
foo(i + j);
</pre></blockquote>

<p>the program would still compile and run correctly.  In either case, the argument can be evaluated to an <b>int</b> value, and that <b>int</b> value is copied into the parameter <b>x</b>.</p>

<p>Secondly, learning C++ implies that we should concern ourselves with performance, in the sense that we should understand the performance impacts of the code that we're writing.  The act of copying a parameter has a cost; its value has to be copied into the activation record during the process of calling the function.  For a small value like an <b>int</b>, this is no burden at all &mdash; and even passing things more indirectly will be no faster.  But <i>all</i> parameters are pass-by-value parameters unless you say otherwise, and the cost of copying them might be a lot higher than the cost of copying an <b>int</b>.  For example, if the argument is a <b>std::string</b> with 100,000 characters, that entire string will need to be copied into a pass-by-value parameter, which is a much more substantial cost to bear.</p>

<p>Thirdly, while they can potentially be expensive, particularly for values that are large or complex, pass-by-value parameters do offer a substantial upside.  You can feel free to call a function and pass a variable to it by value, without worrying that the function can do anything to affect the value of that variable; no matter what the function does, your original copy of the value will be exactly as it was before the call was made.  This is a useful assumption to be able to make about your code, and it can also be a useful assumption for a compiler to make from an optimization perspective.  But you have to weigh that benefit against the cost and decide which is more important to you.</p>

<p class="subtitle">What other kinds of parameter passing are there?</p>

<p>If you don't say anything special, all parameters in C++ are pass-by-value parameters.  However, there are alternative forms that you can ask for, which have a different meaning, have different performance characteristics, and offer different abilities.  We'll need to learn a little more C++, though, in order to be able to use them.</p>

</div>

<div class="section">

<hr />

<p class="title">References</p>

<p>In C++, when you name a storage location &mdash; a variable, a parameter, etc. &mdash; you give that location a type, in addition to its name.  That location establishes a few things about it: its size (i.e., how much memory is required to store it), what you are and aren't allowed to do with it, and how it behaves when you do those things.  So far, we've seen that types, too, have names, such as <b>int</b> and <b>std::string</b>.  But there's more to the story of types in C++ than that, and it's time we learned some more about it.</p>

<p>In C++, a type can be specified as a <i>reference</i>, as opposed to a value.  (If you've learned another programming language like Python or Java previously, you may well have seen a feature called <i>references</i> before, but I should caution you that they're somewhat different in C++ than they are in a lot of other languages in which I've seen them.)</p>

<p>A reference in C++ is said to be "an alternative name for a value."  A reference is said to <i>refer</i> to a value, and it then acts in every way just like the value it refers to; all you've done, in effect, is establish a synonym for that value.</p>

<p>A reference is declared by adding an <b>&amp;</b> character to its type.  So, for example, the type <b>int&amp;</b> is a reference that is required to refer to an <b>int</b> value.  When you see more complex type names like these, it's often useful to read them from right-to-left; that, much more often than not, reveals their meaning.  So I would read <b>int&amp;</b> as "reference (&amp;) to an integer."</p>

<p>There are two important rules about references:</p>

<ol>
  <li>References must be initialized explicitly when they're defined, so that they refer to something of the appropriate type.</li>
  <li>Once a reference is initialized, it cannot be changed to refer to something else; a reference will refer to the same location for its entire lifetime.</li>
</ol>

<p>Once you have a reference to a value, it can be used as though it was the original value, meaning that accessing the reference gives the identical value as accessing the original value, and that changing the reference is identical to changing the original value.</p>

<p>An example illustrates the general idea:</p>

<blockquote><pre>
int i = 3;
int&amp; r = i;                     // <b>r</b> now refers to <b>i</b>
std::cout &lt;&lt; r &lt;&lt; std::endl;    // writes <b>3</b>
r = 4;                          // a change to <b>r</b> is also a change to <b>i</b>
std::cout &lt;&lt; i &lt;&lt; std::endl;    // writes <b>4</b>
i = 5;                          // a change to <b>i</b> is also a change to <b>r</b>
std::cout &lt;&lt; r &lt;&lt; std::endl;    // writes <b>5</b>
</pre></blockquote>

<p>To be clear, the kinds of references we're talking about here actually have a longer name in the C++ Standard: <i>lvalue references</i>.  This is because they always refer, behind the scenes, to a location in memory, so they can only ever refer to an lvalue.  For an illustration of why, what would this block of code mean?</p>

<blockquote><pre>
int&amp; x = 4;                     // How does <b>x</b> refer to the location of the constant 4?
x = 3;                          // What would it mean to change the value of the constant 4?
</pre></blockquote>

<p>References may seem awfully limited when you first encounter them, and it may be a little hard to see what good they are.  But they actually play a vital role in C++; they do a particular job very well.</p>

</div>

<div class="section">

<hr />

<p class="title">Passing references as parameters</p>

<p>If we're permitted to append a <b>&amp;</b> to a type, who's to say that we can't do that with a parameter's type?  And, in fact, this is not only legal, but potentially quite useful.  Let's consider what that use might be, using a slightly modified version of our previous example.</p>

<blockquote><pre>
void foo(int&amp; x)
{
    x++;
    std::cout &lt;&lt; x &lt;&lt; std::endl;
}

int main()
{
    int i = 3;
    foo(i);
    std::cout &lt;&lt; i &lt;&lt; std::endl;
    return 0;
}
</pre></blockquote>

<p>We've seen that there are a couple of rules that references have to follow; are we following those rules here?</p>

<ul>
  <li>References must be initialized explicitly when they're defined, so that they refer to something of the appropriate type.  <i>A parameter of a reference type is "born" when the function is called.  At that time, it is made to refer to the corresponding argument.</i></li>
  <li>Once a reference is initialized, it cannot be changed to refer to something else; a reference will refer to the same location for its entire lifetime.  <i>For the duration of the function's execution, a parameter of a reference type will refer to the corresponding argument.</i></li>
</ul>

<p>Now consider what happens when this program runs.  In particular, when <b>foo()</b> is called, the parameter <b>x</b> is a reference that is made to refer to the local variable <b>i</b> within <b>main()</b>.  This means that any attempt to use <b>x</b> in <b>foo()</b> will result in the value of <b>i</b> from <b>main()</b>, and that any change to <b>x</b> in <b>foo()</b> will change the value of <b>i</b> from <b>main()</b>.  So when <b>foo()</b> updates <b>x</b> by incrementing it, <b>i</b> is also incremented.</p>

<p>Ultimately, then, the key difference in this version of the program is that the second line of output will be <b>4</b> instead of <b>3</b>, because the change to <b>x</b> in <b>foo()</b> has an effect on <b>i</b> in <b>main()</b>.</p>

<p>We sometimes say that parameters like these are <i>pass-by-reference</i> parameters, and they have three important differences from their pass-by-value counterparts:</p>

<ul>
  <li>Pass-by-reference parameters enable functions to alter the arguments that are passed to them.  This can be useful sometimes.</li>
  <li>Passing parameters by reference avoids the cost of making copies of the arguments.  For parameters of types whose values are inexpensive to copy, this is no win (and possibly even a loss), but for parameters that are potentially expensive to copy (like strings or complex data structures), this can be a massive performance benefit.  Unfortunately, we've given up the protection that I can call the function and be certain that the arguments I pass to it won't change, but once we learn more C++, we'll be able to get that protection back again.</li>
  <li>References must refer to lvalues, so it is not possible to pass rvalues as arguments to a function's pass-by-reference parameter.  For example, in the program above, we would no longer be able to write <b>foo(3)</b> in <b>main()</b>, because there would be no location in memory for <b>x</b> to refer to.</li>
</ul>

<p>For a somewhat less contrived example of where pass-by-reference parameters can help, consider the following function that swaps two integers:</p>

<blockquote><pre>
void swap(int&amp; a, int&amp; b)
{
    int temp = a;
    a = b;
    b = temp;
}
</pre></blockquote>

<p>It's not especially difficult to swap two integers, but that's still an error-prone three-line pattern that would read more clearly if it could just be written as <b>swap(i, j);</b>.  The function above makes that possible.  While the function returns no value, it takes its parameters by reference and then modifies those parameters.  (Sadly, if we wanted the same function for swapping <b>double</b>s, <b>float</b>s, <b>std::string</b>s, and so on, we would need separate functions, though we'll learn how to write an infinite set of possible <b>swap</b> functions, all at once, later this quarter.)</p>

</div>

<div class="section">

<hr />

<p class="title">Type conversions between basic types</p>

<p>When you attempt to assign a value into a variable, the types are required to be <i>compatible</i>.  The easiest way for two types to be compatible is for the types to be the same.  For example:</p>

<blockquote><pre>
int i = 3;
int j = 4;
i = j;
</pre></blockquote>

<p>There's no question that assigning the value of <b>j</b> into <b>i</b> is valid, because both <b>i</b> and <b>j</b> have the type <b>int</b>.</p>

<p>However, it is possible for types to be compatible even though they aren't the same.  C++ freely (and implicitly) converts between values of some types when there is a known conversion between them.  For example, C++ will implicitly convert values of all the built-in numeric types, even in cases when information loss is possible.</p>

<blockquote><pre>
int i1 = 4;
double d1 = i1;    // legal

double d2 = 3.5;
int i2 = d2;       // legal
</pre></blockquote>

<p>The assignment of <b>i1</b> into <b>d1</b> is legal, and it's actually quite safe on most architectures.  For example, on the ICS 45C VM, <b>int</b> values are 32 bits, while <b>double</b> values have more than 32 bits of precision, so this assignment will lose no information.</p>

<p>The assignment of <b>d2</b> into <b>i2</b> is also legal, though it does cause information loss (i.e., the fractional part will be lost, and <b>i2</b>'s value will be <b>3</b>).  Some compilers can be configured to provide warnings in cases like these, where information may be lost, but they are technically legal.</p>

<p>This affects our understanding of functions, because the same rules apply when passing arguments to functions:</p>

<ul>
  <li>For a pass-by-value parameter, as long as the corresponding argument is a compatible type (i.e., they're the same, or there's an implicit conversion between them), it will be legal to pass it.</li>
  <li>For a pass-by-reference parameter, the types actually have to match.  Because the reference is referring to the actual location in memory, it's important that this location is treated identically, otherwise assigning to it might give a radically different result than you expected.</li>
</ul>

</div>

<div class="section">

<hr />

<p class="title">Function overloading</p>

<p>We've discussed before that C++ does not allow two definitions for the same name in the same scope.  For example, you can't have two variables called <b>x</b> in the same function.  It turns out, however, that two functions can have the same name in C++ &mdash; even in the same scope &mdash; so long as they are distinguishable by their parameters' types and/or their return types.  The compiler can use the types of arguments and/or the way that the return value is used to unambiguously decide which version of a function you're intending to call.</p>

<p>So you could imagine having multiple versions of the <b>square()</b> function we've written previously.</p>

<blockquote><pre>
long square(long n);
double square(double n);
</pre></blockquote>

<p>Using the same name for functions that operate on different types is called <i>function overloading</i>, which C++ explicitly allows.  However, it has to be clear which version of the function you're calling in any given case, and that can be trickier than it sounds.  Let's see an example of calling our two <b>square()</b> functions.

<blockquote><pre>
int main()
{
    long l1 = 3;
    std::cout &lt;&lt; square(l1) &lt;&lt; std::endl;   // calls square(long)

    double d1 = 3.5;
    std::cout &lt;&lt; square(d1) &lt;&lt; std::endl;   // calls square(double)

    int i1 = 3;
    std::cout &lt;&lt; square(i1) &lt;&lt; std::endl;   // ???

    return 0;
}
</pre></blockquote>

<p>In the first two calls to <b>square()</b>, there is an obvious answer to the question of which version we're calling.  The first call passes a <b>long</b> argument, so we're clearly trying to call the version that accepts a <b>long</b> parameter; the second call passes a <b>double</b>, which matches the version that accepts a <b>double</b>.</p>

<p>But the third call is problematic.  We're passing an argument of type <b>int</b>, which doesn't match either of the versions of <b>square()</b> we've declared.  And since C++ will freely and implicitly convert from <b>int</b> to <b>long</b> <i>or</i> from <b>int</b> to <b>double</b>, the compiler can't be sure what our intent was; either conversion would be legal.  So, in this case, the compiler simply gives us an error message, specifying that there is an ambiguity; in general, the compiler never guesses our intent (which risks guessing wrong, as well as risking that two different compilers might guess differently), but instead expects us to be clear.</p>

<p>The complete rules for resolving overloaded functions in C++ are surprisingly complex, but, in general, there are a few things to know about them:</p>

<ul>
  <li>Exact matches are always taken first, if they exist.  If there's a version of a function that takes precisely the same types of parameters as the types of arguments being passed, that version wins.</li>
  <li>Matches involving promotions (e.g., int &rarr; long, int &rarr; double, float &rarr; double) are taken next.  By <i>promotion</i>, I mean converting from a type with a smaller size to a type with one that's at least as large.</li>
  <li>Matches involving other standard conversions (e.g., double &rarr; int, float &rarr; char) are taken next.</li>
</ul>

<p>There are more rules than these, but this is a good set of rules to bear in mind for this course; we won't write overloaded functions that lead to situations more complicated than these.</p>

</div>

<div class="section">

<hr />

<p class="title">Default arguments</p>

<p>Some functions take a set of parameters, but some of them will quite often have the same value, or there is a sensible default to be used when the caller doesn't know what to pass.  This is common in large, complex libraries, for example.</p>

<p>To help in a situation like this, it's possible to declare a function with <i>default arguments</i>, so that parameters that have common values can be substituted by defaults if they're not specified in calls to that function.  For example, if we wanted to write a function that calculates the length of a vector (in the mathematical sense), but the vector might be specified in either two or three dimensions, we might do it this way.</p>

<blockquote><pre>
double vectorLength(double x, double y, double z = 0.0)
{
    return std::sqrt(x * x + y * y + z * z);
}
</pre></blockquote>

<p>(The <b>std::sqrt</b> function is function in the C++ Standard Library that returns the square root of its argument.)</p>

<p>When we call this function, we can call it with either two or three arguments; whenever we leave out the third argument, its default value is substituted for us automatically.  So all of the following calls are legal, and the last two are equivalent:</p>

<blockquote><pre>
std::cout &lt;&lt; vectorLength(3, 4, 5) &lt;&lt; std::endl;
std::cout &lt;&lt; vectorLength(3, 4, 0) &lt;&lt; std::endl;
std::cout &lt;&lt; vectorLength(3, 4) &lt;&lt; std::endl;
</pre></blockquote>

<p>There is an important rule you need to know, which is that the parameters with default arguments must be listed <i>at the end</i> of the parameter list.  There can be as many defaults as you want, but no parameters without defaults can appear after any that have defaults.  This restriction is not arbitrary; it actually makes good sense.  Since C++ matches arguments to parameters in the order specified &mdash; the first argument is passed to the first parameter, the second to the second, and so on &mdash; the compiler would never know which parameters you meant to pass unless <i>only the last one or more could be missing</i>.</p>

</div>

</body>
</html>
Mis_redirected¢DtypeEvalueõIhttp_code¢DtypeEvalueÈQdownload_complete¢DtypeEvalueõ