¦Ifinal_url¡DtypeLhttp_headers¢DtypeEvalue…¢Ak¢DtypeEvalueDDateAv¢DtypeEvalueXThu, 31 Jan 2019 00:53:09 GMT¢Ak¢DtypeEvalueQTransfer-EncodingAv¢DtypeEvalueGchunked¢Ak¢DtypeEvalueMAccept-RangesAv¢DtypeEvalueEbytes¢Ak¢DtypeEvalueLContent-TypeAv¢DtypeEvalueXtext/html; charset=UTF-8¢Ak¢DtypeEvalueFServerAv¢DtypeEvalueX4Apache/2.4.6 (CentOS) OpenSSL/1.0.2k-fips SVN/1.7.14Kraw_content¢DtypeEvalueY#~<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN"
      "http://www.w3.org/TR/REC-html40/loose.dtd">
<HTML><HEAD>
<TITLE> CompSci 161 Homework #4 </TITLE>
</HEAD><BODY>
<span style="color:#000000; font:16px Arial, Helvetica, sans-serif;">

<H2 align=center> Homework #4 </H2>

<table border=1 cellspacing=0>
<tr><th width="5%">#</th>
    <th width="70%"><font color=red>required problems</font></th>
    <th width="25%">topic</th>
<tr><td align=center>1</td>
    <td>CLRS Exercise 9.3-7 on page 223
      <BR>Describe an <I>O</I>(<I>n</I>)-time algorithm that, given a set <I>S</I>
       of <I>n</I> distinct numbers and a positive integer <I>k</I> &le; <I>n</I>,
       determines the <I>k</I> numbers in <I>S</I> that are closest to the median
       of <I>S</I>.
      </td>
    <td>median selection</td>
<tr><td align=center>2</td>
    <td>GT Exercise C-9.9 on page 280
<!--
       <BR>Given an unsorted sequence <I>S</I> of <I>n</I> comparable elements,
        and an integer <I>k</I>, give an <I>O</I>(<I>n</I> log <I>k</I>)
        expected-time algorithm for finding the <I>O</I>(<I>k</I>) elements
        that have rank
        &lceil;<I>n / k</I>&rceil;</sup>,
        2&lceil;</sup><I>n / k</I>&rceil;</sup>,
        3&lceil;</sup><I>n / k</I>&rceil;</sup>, and so on.
-->
     </td>
    <td>median selection</td>
<tr><td align=center>3</td>
    <td>GT Exercise C-9.10 on page 280
<!--
       <BR>Suppose you are given two sorted lists, <I>A</I> and <I>B</I>,
        of <I>n</I> elements each, all of which are distinct.
        Describe a method that runs in <I>O</I>(log <I>n</I>) time for finding the
        median in the set defined by the union of <I>A</I> and <I>B</I>.
    <td>median selection</td>
<tr><td align=center>4</td>
    <td>GT Exercise R-11.1 on page 319
      <BR>Characterize each of the following recurrence equations using the
        master theorem
      <BR> (assuming that <I>T</I>(<I>n</I>) = <I>c</I> for
        <I>n</I> &lt; <I>d</I>, for constants <I>c</I> &gt; 0 and <I>d</I> &ge; 1).
       <OL type=a>
       <LI> <I>T</I>(<I>n</I>) = 2 <I>T</I>(<I>n</I>/2) + log <I>n</I>
       <LI> <I>T</I>(<I>n</I>) = 8 <I>T</I>(<I>n</I>/2) + <I>n</I><sup>2</sup>
       <LI> <I>T</I>(<I>n</I>) = 16 <I>T</I>(<I>n</I>/2) + (<I>n</I> log <I>n</I>)<sup>4</sup>
       <LI> <I>T</I>(<I>n</I>) = 7 <I>T</I>(<I>n</I>/3) + <I>n</I>
       <LI> <I>T</I>(<I>n</I>) = 9 <I>T</I>(<I>n</I>/3) + <I>n</I><sup>3</sup> log <I>n</I>
       </OL>
SAME AS: CLRS Exercise 9.3-8 on page 223
      <BR>Let <I>X</I>[1..<I>n</I>] and <I>Y</I>[1..<I>n</I>] be two arrays,
       each containing <I>n</I> numbers already in sorted order.
       Give an <I>O</I>(<I>n</I>)-time algorithm to find the median of all
       2<I>n</I> elements in arrys <I>X</I> and <I>Y</I>.
-->
      </td>
    <td>master method</td>

<tr><td align=center>4</td>
    <td>CLRS Exercise 4.5-1 on page 96
      <BR>Use the master method to give tight asymptotic bounds for the
       following recurrences.
      <BR><B>a.</B> <I>T</I>(<I>n</I>) = 2<I>T</I>(<I>n</I>/4) + 1
      <BR><B>b.</B> <I>T</I>(<I>n</I>) = 2<I>T</I>(<I>n</I>/4) + &radic;<I>n</I>
      <BR><B>c.</B> <I>T</I>(<I>n</I>) = 2<I>T</I>(<I>n</I>/4) + <I>n</I>
      <BR><B>d.</B> <I>T</I>(<I>n</I>) = 2<I>T</I>(<I>n</I>/4) + <I>n</I><sup>2</sup>
      </td>
    <td>master method</td>
</table>

<P>

<table border=1 cellspacing=0>
<tr><th width="5%">#</th>
    <th width="70%"><font color="#009900">suggested problems</font></th>
    <th width="25%">topic</th>
<tr><td align=center>5</td>
    <td>GT Exercise A-9.6 on page 281</td>
    <td>selection</td>
<tr><td align=center>6</td>
    <td>CLRS Problem 4-1 on page 107
      <BR>Give asymptotic upper and lower bounds for <I>T</I>(<I>n</I>)
        in each of the following recurrences.
        Assume that <I>T</I>(<I>n</I>) is constant for <I>n</I> &le; 2.
        Make your bounds as tight as possible, and justify your answers.
       <OL type=a>
       <LI> <I>T</I>(<I>n</I>) = 2<I>T</I>(<I>n</I>/2) + <I>n</I><sup>4</sup>
       <LI> <I>T</I>(<I>n</I>) = <I>T</I>(7<I>n</I>/10) + <I>n</I>
       <LI> <I>T</I>(<I>n</I>) = 16<I>T</I>(<I>n</I>/4) + <I>n</I><sup>2</sup>
       <LI> <I>T</I>(<I>n</I>) = 7<I>T</I>(<I>n</I>/3) + <I>n</I><sup>2</sup>
       <LI> <I>T</I>(<I>n</I>) = 7<I>T</I>(<I>n</I>/2) + <I>n</I><sup>2</sup>
       <LI> <I>T</I>(<I>n</I>) = 2<I>T</I>(<I>n</I>/4) + &radic;<I>n</I>
       <LI> <I>T</I>(<I>n</I>) = <I>T</I>(<I>n</I>-2) + <I>n</I><sup>2</sup>
       </OL>
      </td>
    <td>asymptotic bounds for recurrences</td>
<tr><td align=center>7</td>
    <td>CLRS Problem 4-3 on page 108
      <BR>Give asymptotic upper and lower bounds for <I>T</I>(<I>n</I>)
        in each of the following recurrences.
        Assume that <I>T</I>(<I>n</I>) is constant for sufficiently small <I>n</I>.
        Make your bounds as tight as possible, and justify your answers.
       <OL type=a>
       <LI> <I>T</I>(<I>n</I>) = 4<I>T</I>(<I>n</I>/3) + <I>n</I> lg <I>n</I>
       <LI> <I>T</I>(<I>n</I>) = 3<I>T</I>(<I>n</I>/3) + <I>n</I> / lg <I>n</I>
       <LI> <I>T</I>(<I>n</I>) = 4<I>T</I>(<I>n</I>/2) + <I>n</I><sup>2</sup> &radic;<I>n</I>
       <LI> <I>T</I>(<I>n</I>) = 3<I>T</I>(<I>n</I>/3-2) + <I>n</I>/2
       <LI> <I>T</I>(<I>n</I>) = 2<I>T</I>(<I>n</I>/2) + <I>n</I> / lg <I>n</I>
       <LI> <I>T</I>(<I>n</I>) = <I>T</I>(<I>n</I>/2) + <I>T</I>(<I>n</I>/4) + <I>T</I>(<I>n</I>/8) + <I>n</I>
       <LI> <I>T</I>(<I>n</I>) = <I>T</I>(<I>n</I>-1) + 1/<I>n</I>
       <LI> <I>T</I>(<I>n</I>) = <I>T</I>(<I>n</I>-1) + lg <I>n</I>
       <LI> <I>T</I>(<I>n</I>) = <I>T</I>(<I>n</I>-2) + 1 / lg <I>n</I>
       <LI> <I>T</I>(<I>n</I>) = &radic;<I>n</I> <I>T</I>(&radic;<I>n</I>) + <I>n</I>
       </OL>
      </td>
    <td>asymptotic bounds for recurrences</td>
<tr><td align=center>8<font color=blue>*</font></td>
    <td>CLRS Problem 4-5 on pages 109-110
      <BR>Professor Diogenes has <I>n</I> supposedly identical intergrated-circuit
        chips that in principle are capable of testing each other.
        The professor's test jig accommodates two chips at a time.  When the jig is
        loaded, each chip tests the other and reports whether it is good or bad.
        A good chip always reports accurately whether the other chip is good or bad,
        but the professor cannot trust the answer of a bad chip.
        Thus, the four possible outcomes of a test are as follows:
        <P>
        <table>
        <tr align=left><th>Chip <I>A</I> says &nbsp;</th>
            <th>Chip <I>B</I> says &nbsp;</th>
            <th>Conclusion</th>
        <tr><td><I>B</I> is good</td>
            <td><I>A</I> is good</td>
            <td>both are good, or both are bad</td>
        <tr><td><I>B</I> is good</td>
            <td><I>A</I> is bad</td>
            <td>at least one is bad</td>
        <tr><td><I>B</I> is bad</td>
            <td><I>A</I> is good</td>
            <td>at least one is bad</td>
        <tr><td><I>B</I> is bad</td>
            <td><I>A</I> is bad</td>
            <td>at least one is bad</td>
        </table>
        <OL type=a>
        <LI>Show that if more than <I>n</I>/2 chips are bad, the professor cannot
            necessarily determine which chips are good using any strategy based on
            this kind of pairwise test.  Assume that the bad chips can conspire
            to fool the professor.
        <LI>Consider the problem of finding a single good chip from among the
            <I>n</I> chips, assuming that more than <I>n</I>/2 of the chips are good.
            Show that &lfloor;<I>n</I>/2&rfloor; pairwise tests are sufficient to
            reduce the problem to one of nearly half the size.
        <LI>Show that the good chips can be identified with &theta;(<I>n</I>)
            pairwise tests, assuming that more than <I>n</I>/2 of the chips are good.
            Give and solve the recurrence that describes the number of tests.
        </OL>
      </td>
    <td>recursion</td>
<tr><td align=center>9</td>
    <td>DPV Exercise 2.4 on page 71<BR>
        Suppose you are choosing between the following three algorithms:
        <UL>
         <LI>Algorithm A solves problems by dividing them into
             five subproblems of half the size,
             recursively solving each subproblem,
             and then combining the solutions in linear time.
         <LI>Algorithm B solves problems of size <I>n</I> by
             recursively solving two subproblems of size <I>n</I>-1
             and then combining the solutions in constant time.
         <LI>Algorithm C solves problems of size <I>n</I> by dividing them into
             nine subproblems of size <I>n</I>/3,
             recursively solving each subproblem,
             and then combining the solutions in <I>O</I>(<I>n</I><sup>2</sup>) time.
        </UL>
        What are the running times of each of these algorithms
        (in big-<I>O</I> notation), and which would you choose?
    <td>solve recurrences</td>
</table>

<HR>

<small>Last modified: Jan  7, 2018</small>
</span>
</BODY></HTML>
Mis_redirected¢DtypeEvalueôIhttp_code¢DtypeEvalueÈQdownload_complete¢DtypeEvalueõ