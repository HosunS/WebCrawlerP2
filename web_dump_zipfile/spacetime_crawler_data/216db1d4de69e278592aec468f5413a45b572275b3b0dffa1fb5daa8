¦Ifinal_url¡DtypeLhttp_headers¢DtypeEvalue‡¢Ak¢DtypeEvalueNContent-LengthAv¢DtypeEvalueD2946¢Ak¢DtypeEvalueMAccept-RangesAv¢DtypeEvalueEbytes¢Ak¢DtypeEvalueFServerAv¢DtypeEvalueX„Apache/2.4.6 (CentOS) OpenSSL/1.0.2k-fips SVN/1.7.14 mod_wsgi/3.4 Python/2.7.5 Phusion_Passenger/4.0.53 mod_perl/2.0.10 Perl/v5.16.3¢Ak¢DtypeEvalueMLast-ModifiedAv¢DtypeEvalueXWed, 17 Apr 2013 01:53:24 GMT¢Ak¢DtypeEvalueDETagAv¢DtypeEvalueS"b82-4da84c0524d00"¢Ak¢DtypeEvalueDDateAv¢DtypeEvalueXSat, 09 Feb 2019 17:40:30 GMT¢Ak¢DtypeEvalueLContent-TypeAv¢DtypeEvalueXtext/plain; charset=UTF-8Kraw_content¢DtypeEvalueY‚/*  
    $Id: mergeskipmerger.h 4887 2009-12-16 22:01:55Z abehm $  

    Copyright (C) 2010 by The Regents of the University of California
    
    Redistribution of this file is permitted under the terms of 
    the BSD license.

    Author: Jiaheng Lu, Alexander Behm
    Date: 05/14/2007

*/

#ifndef _mergeskipmerger_h_
#define _mergeskipmerger_h_

#include "listmerger.h"

/*
  MergeSkip algorithm.
  Exploit the threshold and
  use binary search to skip elements.
*/

template <class InvList = vector<unsigned> >
class MergeSkipMerger : public ListsMerger<MergeSkipMerger<InvList>, InvList>
{
 public:
  void merge_Impl(const vector<InvList*> &invLists,
		  unsigned threshold,
		  vector<unsigned> &results);
 string getName() {
   return "MergeSkipMerger";
 }
};

template <class InvList>
void  
MergeSkipMerger<InvList>::
merge_Impl(const vector<InvList*> &invLists,
	   unsigned threshold,
	   vector<unsigned> &results) {

  const typename InvList::value_type maxUnsigned = (typename InvList::value_type)0xFFFFFFFF;
  
  unsigned numLists = invLists.size();
  if(threshold > numLists) return;
  
  // add maxUnsigned
  for(unsigned i = 0; i < numLists; i++)
    invLists[i]->push_back(maxUnsigned);

  vector<HeapElement<InvList> > heap;
  heap.reserve(numLists);
  
  // make initial heap
  make_heap(heap.begin(), heap.end());
  for(unsigned i = 0; i < numLists; i++) {
    heap.push_back(HeapElement<InvList>(invLists[i]->begin(), i));
    push_heap(heap.begin(), heap.end());
  }
  
  unsigned pivot = threshold - 1;
  HeapElement<InvList> popped[numLists];
  
  while(*(heap.front().iter) != maxUnsigned) {                       
    
    unsigned count = 0;    
    unsigned currentId = *(heap.front().iter);
    
    while(currentId == *(heap.front().iter) && !heap.empty()) {
      popped[count++] = heap.front();
      pop_heap(heap.begin(), heap.end());
      heap.pop_back();
    }
        
    if(count >= threshold) {
      results.push_back(currentId);
      
      // move to the next element
      for(unsigned i = 0; i < count; i++) {
	popped[i].iter++;
	heap.push_back(HeapElement<InvList>(popped[i].iter, popped[i].invListIndex));
	push_heap(heap.begin(), heap.end());
      }      
      continue;
    }
    
    // pop more elements from heap
    while(count < pivot) {
      popped[count++] = heap.front();
      pop_heap(heap.begin(), heap.end());
      heap.pop_back();
    }
    
    // skip
    for(unsigned i = 0; i < count; i++) {
      popped[i].iter = lower_bound(invLists[popped[i].invListIndex]->begin(), 
				   invLists[popped[i].invListIndex]->end(),
				   *(heap.front().iter));
    }
    
    // insert to heap
    for(unsigned i = 0; i < count; i++) {
      heap.push_back(HeapElement<InvList>(popped[i].iter, popped[i].invListIndex));
      push_heap(heap.begin(), heap.end());
    }
  }
  
  // remove maxUnsigned
  for(unsigned i = 0; i < numLists; i++)
    invLists[i]->pop_back();
}

#endif
Mis_redirected¢DtypeEvalueôIhttp_code¢DtypeEvalueÈQdownload_complete¢DtypeEvalueõ