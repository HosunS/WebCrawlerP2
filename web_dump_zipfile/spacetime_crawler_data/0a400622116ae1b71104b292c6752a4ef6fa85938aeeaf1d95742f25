¦Ifinal_url¢DtypeEvaluexBhttps://www.ics.uci.edu/~thornton/ics45c/Notes/PointersAndTheHeap/Lhttp_headers¢DtypeEvalue‡¢Ak¢DtypeEvalueNContent-LengthAv¢DtypeEvalueE42825¢Ak¢DtypeEvalueMAccept-RangesAv¢DtypeEvalueEbytes¢Ak¢DtypeEvalueFServerAv¢DtypeEvalueX4Apache/2.4.6 (CentOS) OpenSSL/1.0.2k-fips SVN/1.7.14¢Ak¢DtypeEvalueMLast-ModifiedAv¢DtypeEvalueXMon, 14 Jan 2019 23:25:11 GMT¢Ak¢DtypeEvalueDETagAv¢DtypeEvalueT"a749-57f735b2a03c0"¢Ak¢DtypeEvalueDDateAv¢DtypeEvalueXThu, 31 Jan 2019 00:21:02 GMT¢Ak¢DtypeEvalueLContent-TypeAv¢DtypeEvalueXtext/html; charset=UTF-8Kraw_content¢DtypeEvalueY§I<?xml version="1.0" encoding="iso-8859-1"?>
<!DOCTYPE html PUBLIC
 "-//W3C//DTD XHTML 1.1//EN"
 "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">

<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en">

<head>
<meta http-equiv="content-type" content="text/html; charset=iso-8859-1" />
<link rel="stylesheet" href="../../course.css" type="text/css" />

<title>ICS 45C Winter 2019, Notes and Examples: Pointers and the Heap</title>

</head>

<body>

<div class="navbar">

<p>
ICS 45C Winter 2019 |
<a href="../../index.html">News</a> |
<a href="../../CourseReference.html">Course Reference</a> |
<a href="../../Schedule.html">Schedule</a> |
<a href="../../ProjectGuide">Project Guide</a> |
<a href="../../Notes">Notes and Examples</a> |
<a href="http://www.ics.uci.edu/~thornton/">About Alex</a>
</p>

<hr />

</div>

<div class="header">

<p>ICS 45C Winter 2019<br />
   Notes and Examples: Pointers and the Heap</p>

</div>

<div class="section">

<hr />

<p class="title">Why not everything can be statically allocated</p>

<p>We learned previously about objects that are statically allocated and stored on the run-time stack.  There are advantages to statically allocating objects &mdash; most notably, they're deallocated automatically when they fall out of scope &mdash; but it turns out that not everything can be statically allocated, for at least a couple of reasons.</p>

<p class="subtitle">Size matters</p>

<p>Previously, we saw that the C++ Standard Library provides a type called <b>std::string</b>, which encapsulates the idea of text, i.e., a sequence of characters.  But let's stop for a moment to consider what <b>std::string</b> objects might actually look like in memory, based on our previous understanding of static allocation and the run-time stack.  Consider this partial C++ function:</p>

<blockquote><pre>
void foo()
{
    std::string s = "Alex";
    // ...
}
</pre></blockquote>

<p>From our previous understanding of memory allocation, we would conclude that the variable <b>s</b> is a local variable of the function <b>foo()</b>, which we understand to mean that <b>s</b> has been statically allocated and will be stored on the run-time stack, and that it will be deallocated automatically &mdash; along with everything else in <b>foo()</b>'s activation record &mdash; when the function ends.  And, in fact, this is technically true, but there's more to the story than meets the eye in this case.</p>

<p>One of the things that we learned about statically-allocated objects is that they must have a known size at compile time.  For every function, the compiler must determine a precise layout for the function's activation record (i.e., how large the activation record will be, and where within that activation record each local variable, parameter, etc., will be stored).</p>

<p>This brings up an important question: What is the size of <b>s</b>?  Looking at the <b>foo()</b> function above, you might conclude that the string consists of four characters of text, so that its size might be equivalent to four characters (e.g., if each character is one byte, <b>s</b> would be four bytes).  But, unfortunately, it's not that simple: strings can change after they've been created!  What if <b>foo()</b> continued like this?</p>

<blockquote><pre>
void foo()
{
    std::string s = "Alex";

    // ...

    s += " Thornton";

    // ...
}
</pre></blockquote>

<p>How big should <b>s</b> be now?  You might conclude that the compiler could simply determine that, at most, <b>s</b> would have the characters <b>Alex Thornton</b> stored in it, so it could allocate 13 characters' worth of memory.  But there are a couple of problems with that.  First of all, <b>s</b> isn't always 13 characters long; before the use of <b>+=</b>, <b>s</b> is only four characters, though I suppose a compiler could work its way around that, in this particular case.  Secondly, and more importantly, it's not always this simple!  Consider the function <b>bar()</b> below.</p>

<blockquote><pre>
void bar(int n)
{
    std::string s;

    for (int i = 0; i &lt; n; i++)
    {
        s += '-';
    }

    // ...
}
</pre></blockquote>

<p>How big should <b>s</b> be in <b>bar()</b>?  The actual length of the text stored in <b>s</b> can't be determined precisely at compile time, because the loop appends <b>n</b> dashes to an initially-empty string.  So unless the compiler allocates enough memory to store <i>any</i> possible number of dashes &mdash; on our architecture, an <b>int</b> variable might be as large as 2,147,483,647, so we're talking about 2 GB! &mdash; there simply isn't any way to do this correctly.</p>

<p>In other words, not every object has a size that can be determined at compile time.  Some things have sizes determined by input to a function or by other external input to the program (e.g., user input, input sent via a network).  If the size of an object can't be determined at compile time, it can't be allocated statically, and it can't be stored on the run-time stack.  So we'll need to find another alternative.</p>

<p class="subtitle">Object lifetime</p>

<p>While it is quite often the case that an object created in a function will best be destroyed when that function ends, there are plenty of circumstances where this isn't the case.  Some objects need to outlive the functions in which they're created.</p>

<p>For example, maybe we're talking about a function that's part of a server in a massively-multiplayer online game, which is called every time someone connects to the server and logs in.  As a result, some information about that user is allocated and will need to be used in many places throughout the program for as long as the user is still connected, even though the function that handled the connection process has already finished.  Only when the user disconnects, that information will then need to be deallocated.</p>

<p>In some cases like that, you could simply return the value from the initial function that creates it, then pass it as arguments to other functions as you work your way through a program's control flow.  But this can be an expensive proposition &mdash; if the object is large, it might need to copied repeatedly!  And what if you want to store the object in some kind of data structure &mdash; akin to a Python list or a Java ArrayList &mdash; that grows and shrinks over its lifetime?  Now we're back to the same problem we had before: Data structures that grow and shrink over time have sizes that can't be determined at compile time, so their contents can't be statically allocated.</p>

</div>

<div class="section">

<hr />

<p class="title">Dynamic allocation</p>

<p>We've seen previously that the words <i>static</i> and <i>dynamic</i> appear quite frequently when talking about programming languages, and that they quite often are used, broadly, to mean the same kind of thing.  Things that are said to be <i>static</i> are often understood to be things that happen before a program runs (e.g., things that are determined by a compiler), while <i>dynamic</i> things are things that happen while a program runs.</p>

<p>If we're talking about memory allocation, the distinction is the same.</p>

<ul>
  <li><i>Static allocation</i> is done before a program runs.  In the case of C++, that means the compiler determines the object's size and (relative) position in memory (e.g., if it's a local variable of a function, where in that function's activation record the object will be stored).</li>
  <li><i>Dynamic allocation</i> is done while a program runs.  As the program is executing, an object might need to be created on the fly, only to be destroyed at some other time.  In the case of C++, dynamic allocation is done using the keywords <b>new</b> and <b>delete</b>, which, respectively, allocate and deallocate an object dynamically.  (If you've written programs in Python or Java before, it should be noted that most allocation in these languages is actually dynamic, but that the deallocation is done automatically by a <i>garbage collector</i>.  In C++, by contrast, both allocation and deallocation are the programmer's responsibility.)</li>
</ul>

<p>If we consider how the run-time stack is managed, it becomes clear that dynamically-allocated objects wouldn't fit there very well.  If a C++ program can allocate or deallocate an object dynamically at any time, perhaps in wildly different places in a program, possibly deallocating them in wildly different orders than they were allocated, then the run-time stack simply wouldn't be a good place to store them; the run-time stack is managed in a way that is completely dependent on the order in which functions are called and return.</p>

<p>So there must be another area of memory, one that is separate from the run-time stack, that's used to store objects like these, which have dynamic sizes and/or dynamic lifetimes.  This area of memory is called the <i>free store</i> or the <i>heap</i>.  In the heap, anything goes.</p>

<ul>
  <li>Your program decides when memory will be allocated, how much of it will be allocated, and what types of objects will be stored there.  That memory is allocated only when the program explicitly asks to do so.</li>
  <li>Your program decides when memory will be deallocated, making that memory available to be reused elsewhere.  That deallocation happens only when the program explicitly asks to do so, and the memory is not available to any other part of the program until that deallocation has been done.</li>
</ul>

<p>(The terms "free store" and "heap" are used somewhat interchangeably among C++ programmers, though the term "heap" is more common, so I'll stick with that term going forward.  Note, also, that you may have taken a data structures course that discussed a data structure called a "heap" that is used to store objects in a kind of priority-based order; the naming collision here is a coincidence and the heap in a C++ program has nothing to do with that.)</p>

<p>The code generated by a C++ compiler organizes memory in a way that keeps the run-time stack separate from the heap (and, in turn, both of these are kept separate from the areas in memory that store the program's code and its global variables).  Allocation and deallocation in one area has no effect on the other, so you can accurately think of these as simply being separate.</p>

<p class="subtitle">How dynamic allocation is used in std::strings</p>

<p>So, if there are two kinds of memory allocation, this suggests how a local variable <b>s</b> of type <b>std::string</b> might look when stored in memory.  A string is a combination of two areas in memory:</p>

<ul>
  <li>Fixed-size information that describes the string but does not include its text.  Because the size of this information is fixed, it can be allocated at compile time.</li>
  <li>The sequence of characters stored in the string.  Because this can grow and shrink over the lifetime of a string, and because it's not generally possible for a compiler to determine its size, it will need to be dynamically allocated.</li>
</ul>

<p>That suggests an arrangement sort of like this one:</p>

<p><img src="StringMemory.png" alt="Layout of a std::string in memory" /></p>

<p>The <b>length</b> part of <b>s</b> above could simply be an <b>unsigned int</b> value that indicates how many characters of text are contained in <b>s</b>.  For any given compiler, <b>unsigned int</b> values have a known size at compile time (four bytes on the ICS 45C VM), so this part could be allocated statically.</p>

<p>The <b>text</b> part of <b>s</b> is different.  Given what we learned about references, you might conclude that <b>text</b> is a reference.  But it turns out that it can't be.  Because <b>s</b> can be modified during the course of its life &mdash; characters can be added, removed, etc. &mdash; a reference will be problematic, because references can't be pointed to new locations in memory once they're initialized, which will be necessary as the number of characters grows and shrinks.  Remember that references solve a fairly narrow problem in C++: passing or returning a fixed location of a single object.  That's not going to cut it here.</p>

<p>So it looks like we'll need a new tool to solve this problem; references must not be the only way in C++ to track the location of something else.  We need something that can represent the location of an object (i.e., a memory address), but that can be re-pointed to new memory locations over the course of its life.  That tool is called a <i>pointer</i>.</p>

</div>

<div class="section">

<hr />

<p class="title">Pointers</p>

<p>A <i>pointer</i> in C++ is a very thinly-veiled abstraction for a memory location.  A pointer is actually a combination of two things:</p>

<ul>
  <li>A memory address, in a literal sense.  As we've seen, every tiny block of memory &mdash; often, every single byte &mdash; generally has a numeric <i>address</i>, which you can think of as being like an index into a giant array.  So if you want to keep track of the location of something in memory, you need only keep track of its address.</li>
  <li>A type.  Every pointer knows what type of object it's pointing to.</li>
</ul>

<p>In other words, a pointer won't just say "I'm pointing to memory location <i>x</i>."  It'll say "I'm pointing to <i>an integer</i> stored at memory location <i>x</i>."  Given a pointer of a particular type, you'll be limited in terms of how you can treat the object it points to; for example, if it's a pointer to an integer, you'll only be able to do to that object the things you can legally do to integers.  As always, C++'s type system will verify that you're not violating these constraints: pointers to integers can only legally be pointed to integer objects, and the objects they point to can only be treated as integers.</p>

<p>Declaring a variable that stores a pointer to a particular type of object simply requires appending a <b>*</b> to the name of that object's type.  For example, this is the declaration of a pointer variable <b>x</b> that is a pointer to an <b>int</b> object:</p>

<blockquote><pre>
int* x;
</pre></blockquote>

<p>(Note that the precise spacing here can be done in different ways, though I'll adopt the convention of writing the <b>*</b> next to the type, as opposed to writing it next to the variable's name, since it's conceptually part of <b>x</b>'s type.)</p>

<p>As declarations begin to become more complex, it becomes important that we establish a good way to read and understand them.  A good rule of thumb that works in many cases is to read them in a right-to-left manner.  If we do that here, and if we take <b>*</b> to mean "pointer," then we would read the declaration above as "x is a pointer to an integer."</p>

<p class="subtitle">The &amp; (address-of) operator</p>

<p>C++ references store memory addresses only implicitly.  In other words, the variable is, for all intents and purposes, the same as the object the reference refers to.  Behind the scenes, C++ is probably storing a memory address, but there is no name for it; whenever you use the name of the reference, you'll get the object that the reference refers to.</p>

<p>The value of a pointer is different.  Pointers are memory addresses, both explicitly and implicitly.  When you access the value of a pointer, you're accessing the memory address that it stores, not the object stored at that address.  An <b>int*</b> is not interchangeable with an <b>int</b>; it's a pointer to an integer.  The compiler takes this distinction quite seriously, and will carefully ensure that you're not interchanging these concepts in ways that don't make sense.  For example, the following code will result in a compile-time error:</p>

<blockquote><pre>
int i = 3;
int* p = i;   // invalid conversion from int to int*
</pre></blockquote>

<p>The second line will be disallowed because it is an attempt to store an <b>int</b> value into a variable whose type is <b>int*</b>.  While you could argue that memory addresses are simply integers, allowing this would be much more error-prone than the alternative, so the compiler won't let you do it &mdash; at least not without playing some tricks, which we might see later in the course, but that you would only use in rare circumstances where you wanted fine-grained control over precisely what addresses you wanted to store in pointers; I've done that before, but maybe only a tiny handful of times.</p>

<p>However, pointers can be made to point to existing objects, but you need a bit of additional syntax to do it.  There is an operator that you can use in an expression that asks for the address where an object is stored.  It's often called the <i>address-of</i> operator, and is indicated by an <b>&amp;</b>.  When you prefix an object with an <b>&amp;</b> in an expression &mdash; not in a type declaration, where <b>&amp;</b> means something else (i.e., a reference type) &mdash; what you get back is a pointer to that object.</p>

<blockquote><pre>
int i = 3;
int* p = &i;
</pre></blockquote>

<p><img src="Pointers1.png" alt="Diagram of i and p" /></p>

<p>In the example above, <b>p</b> will now store the address where <b>i</b> is located, because the literal meaning of <b>&amp;i</b> is "Give me a pointer that points to <b>i</b>."  Because <b>i</b> has type <b>int</b>, it stands to reason that the pointer you would get back would be an <b>int*</b>, which is why it's legal to store the value of <b>&amp;i</b> into <b>p</b>.  Pictorially, we can now think of <b>p</b> as being sort of like an arrow that points to <b>i</b> &mdash; which is how I quite often draw it or visualize it in my mind &mdash; though, behind the scenes, the arrow is really just a number (i.e., the address in memory where <b>i</b> is).</p>

<p>You can also assign one pointer into another, which wouldn't require the use of the <b>&amp;</b> operator.  This makes a certain amount of sense, because pointers store addresses (constrained by a type), so assigning one pointer into another simply copies that address, the effect of which is that the target would now point to the same object as the source.  For example:</p>

<blockquote><pre>
int i = 3;
int* p = &i;
int* q = p;
</pre></blockquote>

<p><img src="Pointers2.png" alt="Diagram of i, p, and q" /></p>

<p>In this case, <b>p</b> will be a pointer that points to <b>i</b>, and then <b>q</b> will be made to point to the same place <b>p</b> does.  So both pointers are now pointing to <b>i</b>.</p>

<p>I should mention, also, that you can have pointers to pointers, though this isn't something I find myself doing very often &mdash; but it's also not something I've <i>never</i> done.  For example:</p>

<blockquote><pre>
int i = 3;
int* p = &i;
int** q = &p;
</pre></blockquote>

<p><img src="Pointers3.png" alt="Diagram of i, p, and q" /></p>

<p>When we ask for <b>&amp;i</b>, we get a pointer to <b>i</b>; since <b>i</b> is an <b>int</b>, that pointer's type is <b>int*</b>.  When we then ask for <b>&amp;p</b>, we get a pointer to <b>p</b>; since <b>p</b> is an <b>int*</b>, the pointer we get back has the type <b>int**</b> (i.e., read right-to-left as "a pointer to a pointer to an int").  So, in this case, the pointer <b>q</b> points to the pointer <b>p</b>, which, in turn, points to the integer <b>i</b>.</p>

<p class="subtitle">Dereferencing</p>

<p>Pointers wouldn't be much use if you couldn't use them to access the objects they point to.  If a pointer's job is to keep track of where some object is, it stands to reason that you'd need to know where that object is because you plan to do something with it.  When you want to access the object that a pointer points to, you use an operator called the <i>dereference</i> operator (so we often call this <i>dereferencing</i> a pointer), which is represented by <b>*</b>.  When the <b>*</b> operator precedes a pointer in an expression, you're asking for the object that the pointer points to.</p>

<p>(Yes, the operator is called <i>dereference</i>, even though this has nothing to do with references.  Historically, this isn't as crazy as it now sounds; references were added to C++ long after C had a dereference operator that operated on pointers.  But, nowadays, it's an unfortunate collision of terms that can be confusing at first.)</p>

<p>In general, if you have an <b>int* p</b>:</p>

<ul>
  <li><b>p</b> is an expression that evaluates to the pointer itself (i.e., a memory address where you would find an <b>int</b>)</li>
  <li><b>*p</b> is an expression that evaluates to the object that the pointer points to (i.e., an <b>int</b>)</li>
</ul>

<p>It should be noted that <b>*p</b> is an lvalue, so it will be possible to both read from the integer that <b>p</b> points to, and also to change it.</p>

<p>As you might imagine, then, <b>&amp;</b> (address-of) and <b>*</b> (dereference) are the inverse of one another.</p>

<blockquote><pre>
int i = 3;
int* p = &amp;i;
std::cout &lt;&lt; i &lt;&lt; std::endl;
*p = 4;
std::cout &lt;&lt; i &lt;&lt; std::endl;
</pre></blockquote>

<p>The code above, then, would print <b>3</b> and then <b>4</b> to the standard output.</p>

<p class="subtitle">The interaction between pointers and references</p>

<p>Once you understand each of them, pointers and references interact in ways you might expect, though the notation takes some getting used to, particularly because <b>&amp;</b> and <b>*</b> show up in a couple of different ways.  The important thing to remember is that pointers and references aren't the same thing: References are implicit synonyms for objects, whereas pointers explicitly store the location of another object.</p>

<p>A few examples are illustrative here:</p>

<blockquote><pre>
int* p = new int;
*p = 3;

int& q = *p;
q = 4;

std::cout &lt;&lt; *p &lt;&lt; std::endl;

int* r = &amp;q;
*r = 5;

std::cout &lt;&lt; *p &lt;&lt; std::endl;

int*& s = p;
*s = 6;

std::cout &lt;&lt; *p &lt;&lt; std::endl;
</pre></blockquote>

<p>At the conclusion of this code block, the relevant variables and objects might be arranged in memory like this.  (The arrows with dashed lines denote references, the others denote pointers.)</p>

<p><img src="Pointers4.png" alt="Diagram of p, q, r, and s" /></p>

<p>We can trace through this code a line at a time to understand what it means, so we can understand how we ended up with the diagram above.</p>

<ul>
  <li>We first dynamically allocate an integer.  The pointer <b>p</b> now points to it.</li>
  <li>We then assign the value 3 into the dynamically-allocated integer.</li>
  <li>Next, we define <b>q</b>, a reference to an integer.  As we've seen, references have to be made to refer to an object of the appropriate type at the time they're created.  A reference to an integer needs to refer to an integer.  <b>*p</b> is an integer, the integer that <b>p</b> points to, so we can safely refer <b>q</b> to <b>*p</b>.</li>
  <li>We then assign the value 4 into the integer referred to by <b>q</b>.  This is the same integer pointed to by <b>p</b>; its previous value was 3.</li>
  <li>Now we print <b>*p</b>, which is that same integer, so we see the output <b>4</b>.</li>
  <li>Next, we define <b>r</b>, a pointer to an integer, and assign it to point to <b>&amp;q</b>.  This is a bit confusing, but, like many complex things in C++, we can understand it piecemeal.  <b>q</b> is a reference to an integer, but any time we say <b>q</b>, we're talking about the integer; the fact that it's a reference is implicit.  So <b>&amp;q</b> is really a way of asking for the address of the integer that <b>q</b> refers to.  That happens to be the same integer that <b>p</b> points to.  So <b>r</b> is, ultimately, the same address as <b>p</b>; both pointers point to the same place.</li>
  <li>We then assign the value 5 into <b>*r</b>, the integer that <b>r</b> points to.  That's the same integer that <b>p</b> points to, and the same integer that <b>q</b> refers to.  Its value changes from 4 to 5.</li>
  <li>Printing the value of <b>*p</b> displays <b>5</b>.</li>
  <li>Next, we define <b>s</b>.  Reading its type declaration from right to left, we see that "<b>s</b> is a reference to a pointer to an integer."  So, we'll need to initialize it to refer to an <b>int*</b>.  <b>p</b> is an <b>int*</b>, so we can assign <b>s</b> to refer to <b>p</b>.</li>
  <li>We then assign the value 6 into <b>*s</b>.  Fundamentally, <b>s</b> is a reference, so when we say <b>s</b> in this expression, we get the value <b>s</b> refers to.  <b>s</b> refers to the pointer <b>p</b>.  Since we dereferenced that pointer by saying <b>*s</b>, we're saying "Go to where that pointer points."  That pointer points to our same dynamically-allocated integer, whose value is updated to 6.</li>
  <li>Finally, printing the value of <b>*p</b> displays <b>6</b>.</li>
</ul>

<p>One more small wrinkle you should be aware of: There are no pointers to references in C++.  References are treated identically to the objects they refer to, so a pointer to reference would have no useful meaning; it would be no different from a pointer to the object that the reference referred to.  For that reason, C++ simply disallows them.</p>

<p class="subtitle">nullptr</p>

<p>The job of a pointer is to track the location of another object, though there is a situation we've not yet considered.  What if, instead, you want to track the absence of an object (i.e., you want a pointer that indicates that an object is missing)?  This might sound strange at first blush, but it's actually a technique that has more practical use than you might think.</p>

<p>For example, you may have previously seen a data structure called a <i>linked list</i>, which consists of a sequence of values stored in separate objects called <i>nodes</i>.  Each node stores one object in the list, and then keeps track of where the next node is.  The first node tells you the location of the second, the second tells you the location of the third, and so on, and the list's structure arises from the way that they "link together."  In C++, you would typically store a pointer in each node that points to the subsequent node.  But in the last node, which has no node that follows it, what would you store?  Every node will need to look the same, so there will need to be a pointer, even in the last one, but where will the pointer point?  This problem (and lots of problems like it) calls for a pointer that points to no object at all.</p>

<p>In C++, we say that a pointer that points to no object is a <i>null pointer</i>.  As far as the C++ standard is concerned, there are a few ways to say that.  The "modern" way is to use the keyword <b>nullptr</b>, which always evaluates to a null pointer (and is compatible with a pointer of any type, but with no other types).  So, for example, if you wanted a pointer <b>p</b> that pointed to nothing, you would initialize it like this:</p>

<blockquote><pre>
int* p = nullptr;
</pre></blockquote>

<p>Dereferencing a null pointer is considered undefined behavior, though it will most often result in a program crash; the reason is that you're asking for an object that isn't there.  For example, if you do that on a program you run from the Linux shell in the ICS 45C VM, your program will generally crash and you'll see only the error message <b>Segmentation fault</b>, though this behavior can be different on other systems (e.g., on my Windows 10 machine, as of this writing, it will pop up the standard "This program has stopped working" crash dialog box instead).</p>

<p>So this block of code would compile and run, but would crash in the ICS 45C VM:</p>

<blockquote><pre>
int* p = nullptr;
*p = 3;            // CRASH!
</pre></blockquote>

<p class="subtitle">Other ways to say "null"</p>

<p>The <b>nullptr</b> keyword is the notation that I'll use when I want to use the concept of "nullness" in a C++ program, but you should be aware that there are a couple of other ways to do it.  Another way to do it &mdash; which I find to be more obtuse, but is technically legal &mdash; is to use the constant 0, which is also compatible with any pointer type.</p>

<blockquote><pre>
int* p = 0;
</pre></blockquote>

<p>You can't assign non-zero constant integers to a pointer, but you can assign zeroes.  I don't typically like this style, because it can be confusing &mdash; I like things that look, at a glance, like what they are, and this is one more level of indirection in an already-complex language.  But it is worth knowing that pointers can be thought of as being zero (null) or non-zero (not null), because you might see them used as boolean expressions, the same way that integers can be:</p>

<blockquote><pre>
if (p)
{
    // p is non-null
}
else
{
    // p is null
}
</pre></blockquote>

<p>This, too, is not a style I prefer; I would write it this way, because, again, it makes explicit a key detail that I might otherwise easily miss:</p>

<blockquote><pre>
if (p != nullptr)
{
    // p is non-null
}
else
{
    // p is null
}
</pre></blockquote>

<p>Lastly, the C++ Standard Library has long defined a macro called <b>NULL</b> (note the capitalization; that's important) that actually expands to <b>0</b>, so is another way to set a pointer to null:</p>

<blockquote><pre>
int* p = NULL;
</pre></blockquote>

<p>While you'll probably see a fair amount of code online that does this, because <b>nullptr</b> is a fairly recent addition to C++, you should prefer <b>nullptr</b>, as it has the nice property of only being assignable to a pointer type, whereas <b>NULL</b> is literally <b>0</b>, meaning this would also be legal, even though it makes no sense conceptually (though our C++ compiler on the ICS 45C VM will warn you about it):</p>

<blockquote><pre>
int a = NULL;
</pre></blockquote>

<p>

</div>

<div class="section">

<hr />

<p class="title">The "new" and "delete" operators</p>

<p>Thus far, we've seen a lot of the notation used to create and interact with pointers, but it's still not at all clear why you would need them from a practical perspective.  Pointers would be nearly useless if dynamic memory allocation wasn't supported, because their primary use is for accessing objects that have been allocated dynamically (i.e., on the heap).  So, to more fully understand pointers, we need to know how to do dynamic allocation and deallocation.</p>

<p class="subtitle">Dynamically allocating an object</p>

<p>The operator <b>new</b> is used to dynamically allocate an object.  Any type of object can be allocated this way, and the operand of <b>new</b> is the type of object you want.  When you allocate, say, a <b>new int</b>, you've asked for your program to do three things, right then and there:</p>

<ul>
  <li>Find a block of memory on the heap that's not already allocated, one that is big enough to store an <b>int</b>.  (So, for example, on the ICS 45C VM, that would be four bytes.)</li>
  <li>Provided that a block of memory was found &mdash; and we'll talk another time about the consequences of running out of memory and how you deal with them, but we currently lack the techniques in C++ to do so &mdash; that block of memory is allocated, which means that it will be "cordoned off," in a sense, so that it can't be allocated anywhere else until after you explicitly deallocate it later.</li>
  <li>The location of that allocated memory on the heap is returned to you.  Since we're talking about an address in memory, what you get back is a pointer, with the type of that pointer determined by the type of object that you asked for, so <b>new int</b> would give you back an <b>int*</b>.</li>
</ul>

<p>So, in the following example, we dynamically allocate an integer and interact with it.</p>

<blockquote><pre>
void foo()
{
    int* p = new int;
    *p = 3;
    std::cout &lt;&lt; p &lt;&lt; std::endl;
    std::cout &lt;&lt; *p &lt;&lt; std::endl;
    (*p)++;
    std::cout &lt;&lt; *p &lt;&lt; std::endl;
}
</pre></blockquote>

<p>If you ran that code, what would happen is the following:</p>

<ul>
  <li>An <b>int</b> would be dynamically allocated and <b>p</b> would be pointed to it.  That <b>int</b> would be stored on the heap, while the pointer <b>p</b>, which is a local variable in the <b>foo()</b> function, would be stored on the run-time stack.</li>
  <li>The value 3 would be stored in the <b>int</b> that <b>p</b> points to.</li>
  <li>Printing <b>p</b> would show the actual memory address where <b>p</b> points, i.e., the address on the heap where the integer was allocated.  That will work a little differently on different platforms, but on the ICS 45C VM, you would see it show up as 16 hexadecimal digits (since memory address are 64 bits), such as <b>0x000004F08E739B00</b>.</li>
  <li>Printing <b>*p</b> would show the integer value stored at that address.  Since we stored <b>3</b> just after we dynamically allocated the integer, we should see <b>3</b>.</li>
  <li>Incrementing <b>*p</b> would cause the value of <b>*p</b> to be increased by 1.  So the <b>int</b> that <b>p</b> points to will now have the value 4.  (The reason for the parentheses around <b>*p</b> is to override operator precedence; otherwise, we'd be incrementing <b>p</b> and then dereferencing that, and that's a conversation for another day.)</li>
  <li>Printing <b>*p</b> again would display <b>4</b>.</li>
</ul>

<p>When this function ends, its statically-allocated local variables &mdash; namely, the pointer <b>p</b> &mdash; would be destroyed automatically.  When pointers are destroyed, though, the objects they point to are not.  This is by design, actually, because you might have more than one pointer pointing to the same object over the course of time, so it's up to you to manage the deallocation of dynamically-allocated objects.</p>

<p class="subtitle">Dynamically deallocating an object</p>

<p>In a programming language that offers the ability to explicitly allocate objects on a heap, and where objects on the heap have indeterminate lifetime, it is quite common for an <i>automatic garbage collector</i> to be provided.  While more of the details are hidden behind the scenes than they are in C++, both Python and Java, for example, heap-allocate almost all of their objects very similarly to the way C++ does with its <b>new</b> operator.  The main difference is that both Python and Java will periodically discover which objects are no longer in use and deallocate them automatically, so that this deallocation is not something you'll need to manage yourself.</p>

<p>An automatic garbage collector is part of a programming language's <i>runtime system</i>, which is to say that it is interwoven into your program and works alongside it.  The presence of an automatic garbage collector has two positive effects:</p>

<ul>
  <li>It makes it much more difficult (though still not impossible) to suffer from <i>memory leaks</i>.  When you allocate memory dynamically, it is considered to be "in use" and can't be allocated again until it's been deallocated first.  A memory leak is simply allocation without subsequent deallocation, meaning that a program (particularly a long-running program) gradually uses more and more memory until it suffers serious consequences such as a major slowdown or even a crash.  Provided that you don't keep pointers/references to objects that you no longer need, running out of memory is not something you have to think about very much in a garbage-collected language, unless your program needs to actually use a lot of memory at a time.</li>
  <li>Garbage collectors are generally conservative about deleting objects, opting to do so only when they are provably inaccessible, so they make it impossible to have a <i>dangling pointer</i> or <i>dangling reference</i>, which is a pointer/reference to deallocated memory.  If you can access an object, you know it's a "live" object.</li>
</ul>

<p>Given this, an automatic garbage collector sounds like a wonderful thing to be able to depend on, and it certainly can be.  But there's a big problem, from a performance perspective: Automatic garbage collection isn't free.  Depending on the algorithm that's used, it might slow a program down, seemingly randomly introduce noticeably-long pauses into your program, and generally make it more difficult to predict how long individual functions might take to run.  In some kinds of software, that's fine; in others (e.g., control software for robotics or a loop that renders frames in a 3D video game, which are subject to real-time constraints), it's impossible to accept.</p>

<p>For this reason &mdash; and consistent with C++'s basic design philosophy of not including features that impose a cost on those who choose not to use them &mdash; C++ does not include an automatic garbage collector.  This isn't to say that "dead" objects can't be cleaned up, or even that there aren't really good tools that can automate some kinds of cleanup.  But the reality is that deallocating dynamically-allocated objects when you're done with them is ultimately your responsibility as a C++ programmer.  As soon as you use the <b>new</b> operator to allocate an object on the heap, you'll need to consider where and when that object needs to be deallocated with the <b>delete</b> operator.</p>

<p>You can think of the <b>delete</b> operator as being a kind of inverse of the <b>new</b> operator.</p>

<ul>
  <li>The <b>new</b> operator allocates an object on the heap and returns a pointer to it.</li>
  <li>The <b>delete</b> operator takes that same pointer and deallocates the object that it points to.</li>
</ul>

<p>As a somewhat nonsensical example that nevertheless demonstrates the concept, consider this C++ function.</p>

<blockquote><pre>
void foo(int n)
{
    for (int i = 0; i &lt; n; i++)
    {
        int* p = new int;

        // ...
    }
}
</pre></blockquote>

<p>This function runs <b>n</b> iterations of a loop, each of which dynamically allocates an <b>int</b> and then fails to deallocate it.  The effect of calling this function is more insidious than it might appear at first glance.  Every time you call this function, at least <i>O</i>(<i>n</i>) bytes (on the ICS 45C VM, at least four bytes per <b>int</b>) are allocated on the heap.  When the function ends, its local variables and parameters (<b>i</b>, <b>n</b>, and <b>p</b>) &mdash; which are stored on the run-time stack &mdash; are destroyed automatically.  But the dynamically-allocated integers remain on the heap, now unreachable since we have no pointer to any of them; those integers will remain allocated for as long as our program runs, or until the program finally crashes due to having run out of available memory.</p>

<p>By using the <b>delete</b> operator in the body of this loop, so that each of the integers is deallocated when we're done with it, we could call this function with <b>n</b>'s value being as large as we want and never run out of memory.</p>

<blockquote><pre>
void foo(int n)
{
    for (int i = 0; i &lt; n; i++)
    {
        int* p = new int;

        // ...

        delete p;
    }
}
</pre></blockquote>

<p>It's important to reiterate here that <b>delete p</b> doesn't mean what you might think at first glance.  You can read <b>delete p</b> as meaning "Delete the object that the pointer <b>p</b> points to."  In each case, <b>p</b> points to an integer that we dynamically allocated using <b>new</b>; every use of <b>new</b> has a corresponding use of <b>delete</b>, so none of the dynamically-allocated integers leak.</p>

<p>What about the pointer <b>p</b>, though?  Who deletes it?  Remember that it's a local variable, so it's statically allocated; it will be destroyed automatically when the function ends.</p>

<p class="subtitle">The "dangling pointer" problem</p>

<p>There's one more wrinkle to consider when deleting a dynamically-allocated object.  When you delete it, you do so by giving the <b>delete</b> operator a pointer to that object; at that point, the object is deleted, but the pointer is not.  So where does that pointer, then, point?</p>

<p>The answer is that it points just exactly where it did before, to the object that <b>delete</b> just deallocated for us.  So, technically, this code is legal (though certainly not moral):</p>

<blockquote><pre>
int* p = new int;
*p = 3;
delete p;
std::cout << *p << std::endl;
</pre></blockquote>

<p>After the point where we say <b>delete p</b>, the pointer <b>p</b> is still in scope, but dereferencing it (i.e., following it to the now-deallocated memory it points to) results in undefined behavior.  It may accidentally work, it may behave unpredictably, or it may even crash the program.</p>

<p class="subtitle">Words of warning and encouragement</p>

<p>The old saw that "with great power comes great responsibility" applies here.  You have the power to control how memory is allocated <i>and</i> how and when it is deallocated.  This gives you a high level of control over the performance characteristics of the programs you write, but the onus is on you to manage these details correctly.  And the unfortunate part is that mismanaging it will often result in hard-to-find bugs, where programs gradually and quietly use up memory until they run out and grind to a halt, or where programs give unpredictable results or simply crash for no apparent reason.</p>

<p>There are a lot of subtleties to consider whenever you create an object using <b>new</b>.  It's your responsibility as a C++ programmer to think these things through, to implement them correctly, and to test them.  Every time you create an object with <b>new</b>, think about what part of your program should be responsible for deleting it.  If the answer is "the same function in which it was created," what you probably want is a statically-allocated local variable instead, <i>unless</i> the object is particularly large or has an indeterminate size.  If the answer is anything else, now you have some design work to do.</p>

<p>We'll see, as we learn more C++, that there are tools that significantly mitigate problems like these, which automate some of the most common usage patterns that you'll encounter.  But we first have to learn how the underlying, lower-level constructs like <b>new</b> and <b>delete</b> work; they're the tools on top of which the simpler ones are built.</p>

</div>

</body>
</html>
Mis_redirected¢DtypeEvalueõIhttp_code¢DtypeEvalueÈQdownload_complete¢DtypeEvalueõ