¦Ifinal_url¢DtypeEvaluexAhttps://www.ics.uci.edu/~thornton/ics46/Notes/GraphConnectedness/Lhttp_headers¢DtypeEvalue‡¢Ak¢DtypeEvalueNContent-LengthAv¢DtypeEvalueE17107¢Ak¢DtypeEvalueMAccept-RangesAv¢DtypeEvalueEbytes¢Ak¢DtypeEvalueFServerAv¢DtypeEvalueX4Apache/2.4.6 (CentOS) OpenSSL/1.0.2k-fips SVN/1.7.14¢Ak¢DtypeEvalueMLast-ModifiedAv¢DtypeEvalueXSun, 20 May 2018 17:08:47 GMT¢Ak¢DtypeEvalueDETagAv¢DtypeEvalueT"42d3-56ca63cfae5c0"¢Ak¢DtypeEvalueDDateAv¢DtypeEvalueXFri, 01 Feb 2019 10:23:47 GMT¢Ak¢DtypeEvalueLContent-TypeAv¢DtypeEvalueXtext/html; charset=UTF-8Kraw_content¢DtypeEvalueYBÓ<?xml version="1.0" encoding="iso-8859-1"?>
<!DOCTYPE html PUBLIC
 "-//W3C//DTD XHTML 1.1//EN"
 "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">

<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en">

<head>
<meta http-equiv="content-type" content="text/html; charset=iso-8859-1" />
<link rel="stylesheet" href="../../course.css" type="text/css" />

<title>ICS 46 Spring 2018, Notes and Examples: Graph Connectedness</title>

</head>

<body>

<div class="navbar">

<p>
ICS 46 Spring 2018 |
<a href="../../index.html">News</a> |
<a href="../../CourseReference.html">Course Reference</a> |
<a href="../../Schedule.html">Schedule</a> |
<a href="../../ProjectGuide">Project Guide</a> |
<a href="../../Notes">Notes and Examples</a> |
<a href="http://www.ics.uci.edu/~thornton/">About Alex</a>
</p>

<hr />

</div>

<div class="header">

<p>ICS 46 Spring 2018<br />
   Notes and Examples: Graph Connectedness</p>

</div>

<div class="section">

<hr />

<p class="title">Background</p>

<p>When we learned previously about <a href="../GraphTraversals">graph traversals</a>, we discovered that there were some complications involved in traversing graphs that we didn't encounter when we were traversing trees.  One of those complications arose when we tried to traverse a graph that lacked you might generally call <i>connectedness</i>, which is to say that you may not necessarily be able to start at one vertex and reach every other vertex in the graph simply by following the available edges; some of them might be unreachable.  This wasn't a problem that was particularly difficult to work around, but we did have to recognize it and allow for it in the design of our traversal algorithms.</p>

<p>It's important to note, also, that a lack of connectedness wasn't at all unrealistic; it's not just a theoretical problem.  You could consider the collection of people who use Facebook and their friend relationships to be a directed graph; each person would be one vertex in the graph, while each instance of a person A listing person B as a friend would be a directed edge from vertex A to vertex B.  Now suppose that two people create Facebook accounts for the first time, and they each list one another as a friend.  For now, these two people are a sort of island in the graph; they're disconnected from anyone else, with no path (via friend relationships) able to reach from either of them to anyone other than them (or vice versa).</p>

<p>So it's certainly the case that we'll need to consider the effect that connectedness has on various graph algorithms.  It's not a bad idea, either, to be sure we understand what connectedness really means, and that it's not quite as simple of a concept as it sounds, particularly when we're talking about directed graphs.  Let's explore this topic a little more thoroughly.</p>

</div>

<div class="section">

<hr />

<p class="title">Connectedness in undirected graphs</p>

<p>What do we mean when we talk about the <i>connectedness</i> of an undirected graph?  The story actually starts with a related definition, which talks about the <i>connectedness</i> of two vertices.</p>

<blockquote>
We say that two vertices <i>v</i> and <i>w</i> in an undirected graph are <i>connected</i> if there is a path containing both <i>v</i> and <i>w</i>.
</blockquote>

<p>Recall that a <i>path</i> in a graph is a sequence of vertices where each vertex in the sequence has an edge leading to the vertex that follows it.  So, generally, this definition just means that two vertices are connected if you can start with one of them, follow a sequence of edges, and eventually end up at the other one.</p>

<p>The definition above leads to a broader definition of whether an entire undirected graph is connected.</p>

<blockquote>
We say that an undirected graph is <i>connected</i> if every pair of vertices in the graph is connected.
</blockquote>

<p>In other words, in an undirected graph that is connected, you can start anywhere and follow edges to get anywhere else.  Consider this definition in relation to the two undirected graphs, G<sub><small>1</small></sub> and G<sub><small>2</small></sub>, below.</p>

<p class="center"><img src="Graphs_UndirectedConnectedness.png" alt="Connectedness of undirected graphs" /></p>

<p>With undirected graphs, it's reasonably straightforward to look at them quickly and determine their connectedness.  G<sub><small>1</small></sub> is clearly connected; no matter which vertex you choose, you'll be able to reach any of the others.  G<sub><small>2</small></sub>, on the other hand, is clearly not, because it consists of two separate "islands," which are technically called <i>connected components</i>.</p>

<blockquote>
We say that a subset of the vertices in an undirected graph is a <i>connected component</i> if every pair of vertices in the subset is connected, but none of the vertices is connected to any vertex outside of the subset.
</blockquote>

<p class="subtitle">An algorithm for determining the connectedness of an undirected graph</p>

<p>The depth-first <a href="../GraphTraversals">graph traversal</a> algorithm we saw previously nicely forms the basis of an algorithm for determining whether an undirected graph is connected.  Recall that our depth-first graph traversal algorithm actually had two parts:</p>

<ul>
  <li><b>DFT</b>, which was the complete depth-first traversal.</li>
  <li><b>DFTr</b>, which was a recursive, depth-first traversal starting at some vertex, which would reach only the vertices that were reachable from where we started.</li>
</ul>

<p>If all we want to know is whether an undirected graph is connected, there's an easy way to do it.  Below is an algorithm that uses <b>DFTr</b>, with the additional presumption that the <b>visit</b> step simply adds 1 to the <b>visitedCount</b>.</p>

<blockquote><pre>
IsConnected(UndirectedGraph g):
    startVertex = <i>any vertex in g</i>
    visitedCount = 0

    DFTr(g, startVertex)

    return visitedCount == <i>number of vertices in g</i>
</pre></blockquote>

<p>So, generally, we run a single <b>DFTr</b> from the start vertex, adding 1 to <b>visitedCount</b> every time we visit a vertex.  When we're done, the counter will tell us how many vertices were reached.  If we reached all of the vertices (i.e., if the counter equals the number of vertices in the graph), the undirected graph is connected; otherwise, it's not.  (If it seems strange to you that it's possible for <b>visit</b> to add 1 to a local variable in <b>IsConnected</b>, note that there are lots of ways to achieve this kind of goal in C++: a member variable in a class, a lambda expression that captures the local variable by reference, or even a global variable.)</p>

<p>We can also modify our algorithm slightly to find the connected components instead.  For this, we'll instead say that the <b>visit</b> step will assign a <b>componentNumber</b> to the vertex being visited.</p>

<blockquote><pre>
FindConnectedComponents(UndirectedGraph g):
    for each vertex v in g:
        v.visited = false

    componentNumber = 0

    for each vertex v in g:
        if not v.visted:
            componentNumber++
            DFTr(g, v)    
</pre></blockquote>

<p>The <b>FindConnectedComponents</b> algorithm is a lightly-modified version of <b>DFT</b>, which increments a <b>componentNumber</b> variable each time we start a new call to <b>DFTr</b>.  If the <b>visit</b> step in <b>DFTr</b> assigns that <b>componentNumber</b> to each vertex it visits, then when we're done, all of the vertices in each connected component will be marked with the same <b>componentNumber</b>, and any two vertices in different connected components will be marked with a different <b>componentNumber</b>.</p>

<p>Try these algorithms on the two undirected graphs above to make sure you understand how they work.</p>

<p class="subtitle">Asymptotic analysis of the algorithms</p>

<p>Since these algorithms are ultimately nothing more than depth-first traversals with slightly different <b>visit</b> implementations, each of which takes &Theta;(1) time to run, the analysis here is straightforward.</p>

<ul>
  <li>Recall that a complete depth-first traversal runs in &Theta;(<i>v</i><sup><small>2</small></sup>) or &Theta;(<i>v</i> + <i>e</i>) time, depending on how the graph is implemented.</li>
  <li><b>IsConnected</b> runs in <i>O</i>(<i>v</i><sup><small>2</small></sup>) or <i>O</i>(<i>v</i> + <i>e</i>) time, then, since it may not run a complete traversal (i.e., if the graph is disconnected and you choose a vertex that has relatively few other vertices in its connected component, you'll only reach those).</li>
  <li><b>FindConnectedComponents</b> runs in &Theta;(<i>v</i><sup><small>2</small></sup>) or &Theta;(<i>v</i> + <i>e</i>) time, since it does a complete depth-first traversal of the entire graph.</li>
</ul>

</div>

<div class="section">

<hr />

<p class="title">Connectedness in directed graphs</p>

<p class="subtitle">Strong connectedness and weak connectedness</p>

<p>Connectedness in directed graphs is a slightly more intricate concept, because the directionality of the edges introduces the possibility of two vertices being connected in one direction but not the other (i.e., just because there is a path leading from <i>v</i> to <i>w</i> does not imply that there is a path leading from <i>w</i> to <i>v</i>).  This basic observation leads to two separate definitions of connectedness, embodied by the two directed graphs below.</p>

<p class="center"><img src="Graphs_DirectedConnectedness.png" alt="Connectedness of a directed graph" /></p>

<p>The graph on the left, <i>G</i><sub><small>3</small></sub> is one that appears to be connected when you look at it quickly, but the directionality of its edges reveals an important shortcoming: From <i>a</i>, it's possible to reach every vertex; but from any other vertex, there is at least one other vertex that you can't reach.  On the other hand, the graph on the right, <i>G</i><sub><small>4</small></sub> doesn't have this problem; no matter where you start, you'll be able to reach every vertex in the graph.</p>

<p>To describe the distinction between these kinds of connectedness in a directed graph, we use the terms <i>weakly connected</i> and <i>strongly connected</i>, with <i>G</i><sub><small>3</small></sub> being weakly connected and <i>G</i><sub><small>4</small></sub> being strongly connected.</p>

<p>To be more formal, we define strong connectedness this way:</p>

<blockquote>
We say that a directed graph is <i>strongly connected</i> if, for every pair of vertices <i>v</i> and <i>w</i>, there is a path from <i>v</i> to <i>w</i> <u>and</u> a path from <i>w</i> to <i>v</i>.
</blockquote>

<p>The graph <i>G</i><sub><small>4</small></sub>, being one that contains a cycle that includes every vertex, is one that certainly has this property.  On the other hand, <i>G</i><sub><small>3</small></sub> does not meet this property, because, for example, there is no path leading from the vertex <i>b</i> to the vertex <i>a</i>.</p>

<p>Meanwhile, we define weak connectedness a little bit differently, first defining something else called the <i>underlying undirected graph</i>.</p>

<blockquote>
The <i>underlying undirected graph</i> of a directed graph is one with the same set of vertices, but a different set of edges.  In particular, between any pair of vertices <i>v</i> and <i>w</i>, if the directed graph has an edge <i>v</i> &rarr; <i>w</i> or an edge <i>w</i> &rarr; <i>v</i>, the underlying undirected graph includes an edge {<i>v</i>, <i>w</i>}.
</blockquote>

<p>The underlying undirected graph for the graph <i>G</i><sub><small>3</small></sub> above looks like this:</p>

<p class="center"><img src="Graphs_UnderlyingUndirected.png" alt="The underlying undirected graph of G1" /></p>

<p>Additionally, note that since undirected graphs can't have "self-edges" (i.e., an edge <i>v</i> &rarr; <i>v</i>, for some vertex <i>v</i>), we simply remove them; they're not included in the underlying undirected graph.</p>

<p>Given this definition, we define weak connectedness as follows:</p>

<blockquote>
We say that a directed graph is <i>weakly connected</i> if its underlying undirected graph is connected.
</blockquote>

<p>This definition codifies the general notion that weakly connected directed graphs are the ones that "look connected" when you don't consider the directionality of their edges, while also suggesting an algorithm for determining weak connectedness.</p>

<p>There's one more thing to note: All graphs that are strongly connected are also weakly connected.  For example, the graph <i>G</i><sub><small>4</small></sub> has the same underlying undirected graph as <i>G</i><sub><small>3</small></sub> does, so it, too, is weakly connected.</p>

<p class="subtitle">An algorithm for determining weak connectedness of a directed graph</p>

<p>If we want to test that a directed graph is weakly connected, we have a couple of choices:</p>

<ul>
  <li>Build the underlying undirected graph</li>
  <li>Traverse the directed graph as though it was the underlying undirected graph, by treating the edges as though they have no direction</li>
</ul>

<p>How you make that decision has mostly to do with the way that the graph is implemented.</p>

<ul>
  <li>If the directed graph is implemented as an adjacency matrix, it can be traversed as though it was the underlying undirected graph by simply looking at an entire row <u>and</u> an entire column each time you want to find the outgoing edges from some vertex.  This will easily find all edges <i>v</i> &rarr; <u>anything</u> and <u>anything</u> &rarr; <i>v</i></li>
  <li>If the directed graph is implemented as adjacency lists, it will be better to simply build the underlying undirected graph, since finding all incoming edges for some vertex will require searching all of the lists.</li>
</ul>

<p>From there, the algorithm is the same as the one for finding out whether an undirected graph is connected.  If the underlying undirected graph is connected, the directed graph is weakly connected; if not, it isn't.</p>

<p>The asymptotic analysis is straightforward:</p>

<ul>
  <li>Building the underlying undirected graph would require iterating through the entire structure and making a (slightly different) copy of it, which would take &Theta;(<i>v</i><sup><small>2</small></sup>) or &Theta;(<i>v</i> + <i>e</i>), depending on how the graph is implemented (i.e., matrix or lists).</li>
  <li>Testing for connectedness of the underlying undirected graph would require <i>O</i>(<i>v</i><sup><small>2</small></sup>) or <i>O</i>(<i>v</i> + <i>e</i>) time, again depending on how the graph is implemented.</li>
  <li>The total time would be &Theta;(<i>v</i><sup><small>2</small></sup>) or &Theta;(<i>v</i> + <i>e</i>) if the underlying undirected graph is built, or <i>O</i>(<i>v</i><sup><small>2</small></sup>) or <i>O</i>(<i>v</i> + <i>e</i>) if not.</li>
</ul>

<p class="subtitle">An algorithm for determining strong connectedness of a directed graph</p>

<p>As we've seen, depth-first traversals can form the basis of many graph algorithms, so we might expect a depth-first traversal to be a good choice here.  And, indeed, you can use a depth-first traversal to find out whether a directed graph is strongly connected, but you have to be a bit careful about how you apply it.</p>

<p>To understand what we need to do, consider the graph <i>G</i><sub><small>3</small></sub> above, which is not strongly connected.  Suppose that you ran a <b>DFTr</b> starting from the vertex <i>a</i>.  If you did, you'd reach every vertex, which is a positive result, but isn't enough; it establishes that there is a path from <i>a</i> to every vertex, but not that there is a return path from those vertices back to <i>a</i>.  This tells us that just performing a <b>DFTr</b> that reaches every vertex isn't enough.</p>

<p>One approach that would work would be to simply run a separate <b>DFTr</b> starting at every vertex.  If they <i>all</i> reach every vertex, then you would be sure that the graph was strongly connected.</p>

<p>The asymptotic analysis, again, would be straightforward.  We know that a single call to <b>DFTr</b> takes <i>O</i>(<i>v</i><sup><small>2</small></sup>) or <i>O</i>(<i>v</i> + <i>e</i>) time (depending on the graph's implementation).  Running as many as <i>v</i> of these calls &mdash; one for each vertex &mdash; would then take <i>O</i>(<i>v</i><sup><small>3</small></sup>) or <i>O</i>(<i>v</i><sup><small>2</small></sup> + <i>ve</i>) time.</p>

<p>It should be noted that there are better algorithms than this one, such as Tarjan's Algorithm and Kosaraju's algorithm, though we didn't discuss either of these in class and are outside the scope of this course, but might make for interesting additional study if you're curious about them.</p>

</div>

</body>
</html>
Mis_redirected¢DtypeEvalueõIhttp_code¢DtypeEvalueÈQdownload_complete¢DtypeEvalueõ