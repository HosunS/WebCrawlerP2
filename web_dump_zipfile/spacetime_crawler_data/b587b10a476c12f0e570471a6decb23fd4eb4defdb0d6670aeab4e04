¦Ifinal_url¡DtypeLhttp_headers¢DtypeEvalue‡¢Ak¢DtypeEvalueNContent-LengthAv¢DtypeEvalueD2270¢Ak¢DtypeEvalueMAccept-RangesAv¢DtypeEvalueEbytes¢Ak¢DtypeEvalueFServerAv¢DtypeEvalueXjApache/2.4.6 (CentOS) OpenSSL/1.0.2k-fips SVN/1.7.14 Phusion_Passenger/4.0.53 mod_perl/2.0.10 Perl/v5.16.3¢Ak¢DtypeEvalueMLast-ModifiedAv¢DtypeEvalueXWed, 17 Apr 2013 01:54:00 GMT¢Ak¢DtypeEvalueDETagAv¢DtypeEvalueS"8de-4da84c2779e00"¢Ak¢DtypeEvalueDDateAv¢DtypeEvalueXSun, 10 Feb 2019 00:20:36 GMT¢Ak¢DtypeEvalueLContent-TypeAv¢DtypeEvalueXtext/plain; charset=UTF-8Kraw_content¢DtypeEvalueYÞ/*
  $Id: gramlistondisk.h 5751 2010-10-01 17:31:22Z abehm $

  Copyright (C) 2010 by The Regents of the University of California
	
  Redistribution of this file is permitted under
  the terms of the BSD license.
    
  Date: 09/06/2008
  Author: Alexander Behm <abehm (at) ics.uci.edu>
*/

#ifndef _gramlistondisk_h_
#define _gramlistondisk_h_

#include "gramlist.h"

#include <iostream>
#include <cstring>

template <typename InvList = vector<unsigned> >
class GramListOnDisk : public GramList<InvList> {
private:
  InvList* invList;

public:
  unsigned listSize;
  streampos startOffset;
  
  GramListOnDisk()
    : invList(NULL), listSize(0), startOffset(0) {}
  
  GramListOnDisk(unsigned listSize, streampos& startOffset)
    : invList(NULL), listSize(listSize), startOffset(startOffset) {}
  
  InvList* getArray(fstream* invListsFile = NULL) {     
    if(invList) return invList;
    //cout << "NOT RETURNING IMMEDIATELY?!" << endl;
    if(!invListsFile) return NULL;    
    invList = new InvList(listSize);
    invList->reserve(listSize);
    invList->resize(listSize);
    unsigned bytes = listSize * sizeof(typename InvList::value_type);
    invListsFile->seekg(startOffset);
    invListsFile->read((char*)&invList->at(0), bytes);
    return invList;
  }
  
  // fill the array from the given get position of the file stream
  // old invList will be deleted
  // no disk seek is performed
  void fillArray(fstream* invListsFile) {
    if(invList) clear();
    invList = new InvList(listSize);
    invList->reserve(listSize);
    invList->resize(listSize);
    unsigned bytes = listSize * sizeof(typename InvList::value_type);
    if(invListsFile->tellg() != startOffset) 
      cout << "THERE IS A PROBLEM HERE" << endl;
    invListsFile->read((char*)&invList->at(0), bytes);
  }
  
  void fillArray(char* data) {
    if(invList) clear();
    invList = new InvList(listSize);
    invList->reserve(listSize);
    invList->resize(listSize);
    unsigned bytes = listSize * sizeof(typename InvList::value_type);
    memcpy((char*)&invList->at(0), (const void*)data, bytes);    
  }
  
  void clear() {
    if(invList) delete invList;
    invList = NULL;
  }

  void free() {
    clear();
    delete this;
  }

  ~GramListOnDisk() {
    clear();
  }
};

#endif
Mis_redirected¢DtypeEvalueôIhttp_code¢DtypeEvalueÈQdownload_complete¢DtypeEvalueõ