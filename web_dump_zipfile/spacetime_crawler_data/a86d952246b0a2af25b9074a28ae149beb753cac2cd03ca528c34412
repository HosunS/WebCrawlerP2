¶Ifinal_url¢DtypeEvaluex6https://www.ics.uci.edu/~thornton/ics45c/Notes/Basics/Lhttp_headers¢DtypeEvalueá¢Ak¢DtypeEvalueNContent-LengthAv¢DtypeEvalueE43151¢Ak¢DtypeEvalueMAccept-RangesAv¢DtypeEvalueEbytes¢Ak¢DtypeEvalueFServerAv¢DtypeEvalueX4Apache/2.4.6 (CentOS) OpenSSL/1.0.2k-fips SVN/1.7.14¢Ak¢DtypeEvalueMLast-ModifiedAv¢DtypeEvalueXMon, 07 Jan 2019 04:34:31 GMT¢Ak¢DtypeEvalueDETagAv¢DtypeEvalueT"a88f-57ed6beb223c0"¢Ak¢DtypeEvalueDDateAv¢DtypeEvalueXWed, 30 Jan 2019 23:56:39 GMT¢Ak¢DtypeEvalueLContent-TypeAv¢DtypeEvalueXtext/html; charset=UTF-8Kraw_content¢DtypeEvalueY®è<?xml version="1.0" encoding="iso-8859-1"?>
<!DOCTYPE html PUBLIC
 "-//W3C//DTD XHTML 1.1//EN"
 "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">

<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en">

<head>
<meta http-equiv="content-type" content="text/html; charset=iso-8859-1" />
<link rel="stylesheet" href="../../course.css" type="text/css" />

<title>ICS 45C Winter 2019, Notes and Examples: C++ Basics</title>

</head>

<body>

<div class="navbar">

<p>
ICS 45C Winter 2019 |
<a href="../../index.html">News</a> |
<a href="../../CourseReference.html">Course Reference</a> |
<a href="../../Schedule.html">Schedule</a> |
<a href="../../ProjectGuide">Project Guide</a> |
<a href="../../Notes">Notes and Examples</a> |
<a href="http://www.ics.uci.edu/~thornton/">About Alex</a>
</p>

<hr />

</div>

<div class="header">

<p>ICS 45C Winter 2019<br />
   Notes and Examples: C++ Basics</p>

</div>

<div class="section">

<hr />

<p class="title">What is a C++ program?</p>

<p>A C++ program is a collection of <i>functions</i>.  C++ functions, like their counterparts in other programming languages (variously referred to as functions, <i>procedures</i>, <i>subroutines</i>, <i>methods</i>, and so on), encapsulate the code necessary to perform a single task.  Functions are <i>called</i> to perform their task, and then <i>return</i> a result when they're finished.  Each function has a name, accepts a set of <i>parameters</i>, does some kind of job when called, and returns a value (or, sometimes, no value at all).</p>

<p>Executing a C++ program is generally done by calling a function with the name <b>main</b>.  The C++ Standard requires <b>main</b> to return an integer value, though it does not need to take parameters.  (The <b>main</b> function can take parameters, as we'll see later in the course, but this is a feature we'll use only rarely.)  The program begins with the call to <b>main</b> and ends when <b>main</b> returns.</p>

<p>So the simplest C++ program you could write is the one below, which contains only a <b>main</b> function that does nothing except return the integer value 0.</p>

<blockquote><pre>
int main()
{
    return 0;
}
</pre></blockquote>

<p>There are a few things worth noting about this simplest of examples.</p>

<p>The first line of the function is called its <i>signature</i>.  The signature specifies how to call the function, consisting of three parts:</p>

<ul>
  <li>A <i>return type</i> (i.e., what type of value the function will return).  In this case, we've specified that it will return an integer value, which we represent using the built-in C++ type <b>int</b>.</li>
  <li>A <i>name</i>.  In this case, that name is <b>main</b>.</li>
  <li>A sequence of <i>parameters</i> surrounded by parentheses.  In this case, there are no parameters, so we don't list any, though we still have to write the parentheses.</li>
</ul>

<p>After the function's signature, we see the function's <i>body</i>, which specifies what the function actually does when it's called.  The body is written as a sequence of <i>statements</i>, surrounded by funny-looking characters often called <i>curly braces</i>.  The only thing our <b>main()</b> function does is return the value 0.</p>

<p>Unlike in some languages, there are few specific layout rules (e.g., spacing, indention).  We could have written that same function all on a single line:</p>

<blockquote><pre>
int main() { return 0; }
</pre></blockquote>

<p>However, in general, I'll use spacing and indention to highlight the syntactic structure of our functions, and we'll expect you to do the same, and for good reason: Tidy-looking code is easier to read and understand (particularly for people who didn't write it, or for the author months or years later after the details have been forgotten).</p>

<p class="subtitle">Where does main()'s return value go?</p>

<p>Ordinarily, C++ functions are called by other C++ functions.  As in many programming languages, when the called function returns a value, the calling function can then make use of that value in whatever (reasonable and legal) way it would like.</p>

<p>But this brings up an interesting question: If the <b>main()</b> function is the entry point of the entire program, why does it return a value, and to whom is the value returned?  Every program running on operating systems like Windows, Mac OS X, and Linux returns an <i>exit code</i> back to the operating system when it's done.  This makes it possible to orchestrate the execution of many programs (e.g., using <i>shell scripts</i> on Linux) and have that orchestration be done differently depending on the result of each program.  Most commonly, an exit code of 0 is used to indicate success, while other exit codes are used to indicate various kinds of failures; checking for an exit code of 0 from the first program might tell you which program you should run next, or whether to run a second one at all.  This kind of thing is out of the scope of our work this quarter, so we'll almost always return 0 from <b>main()</b>.</p>

</div>

<div class="section">

<hr />

<p class="title">Compilation, types, and static type checking</p>

<p>When you use some programming languages &mdash; Python being a notable example &mdash; each iteration of writing a program involves two steps: editing your code, then running the program (or a part of the program) to analyze whether it's behaving as you expect.  Provided that the program is syntactically correct (i.e., it has the proper structure throughout) when you're done editing it, the program runs, and most non-syntax mistakes manifest themselves as run-time errors.</p>

<p>The process you follow when writing a C++ program is decidedly different.  In C++, each iteration is actually a three-step process:</p>

<ul>
  <li><i>Edit your code</i>, making whatever changes you wanted to make (e.g., adding a new feature, fixing a previous mistake, or whatever).</li>
  <li><i>Compile your program</i>.  In short, <i>compilation</i> is the process of taking the code you wrote and translating it into an executable program (i.e., machine code capable of executing directly on your chosen target machine).  In the process of performing that translation, the compiler checks for a broader range of mistakes, and compilation fails if your program is incorrect either syntactically <i>or semantically</i>.  If compilation fails because it's detected that you've made some kind of mistake that it checked for, you go back to the first step and edit your code again.</li>
  <li><i>Run your program</i>.  Once compilation has succeeded, you can then run your program.  On the other hand, if compilation fails, you <i>can't</i> run the program, which means that certain kinds of errors &mdash; the ones that the compiler checks for &mdash; simply can't occur at run time.</li>
</ul>

<p>One of the key ways that C++ feels different from a language like Python, particularly when you're first getting acquainted with it, is that C++ takes the idea of <i>types</i> &mdash; what kind of values are permitted to be stored in a variable, returned from a function, and so on &mdash; very seriously.  In fairness, languages like Python take types seriously, as well; if you try to misuse types, such as subtracting a string from a string in Python, you'll get an error, just as you would in C++.  But C++ feels very different in a couple of ways:</p>

<ul>
  <li>When you want to use a variable or a parameter, or when you want to return a value from a function, you'll need to specify what type of value you intend to store, pass, or return.</li>
  <li>The compiler will check that the values you actually store in a variable, pass into a parameter, or return from a function match the intentions you stated in your code.  When you try to, say, return a string from a function that you've said should return an integer, the compiler will emit an error message, <i>and compilation will fail</i>.</li>
</ul>

<p>Overall, this process is called <i>static type checking</i>.  The word <i>static</i>, in this context, can be taken to mean "Done before the program runs" (i.e., by the compiler).  Note that the incorporation of static type checking is in stark contrast to some other languages like Python, Ruby, and JavaScript, where there is only <i>dynamic type checking</i> (i.e., issues related to types are checked while the program is running, but not before).  It is quite common for languages with dynamic type checking to have a simpler syntax, particularly in the sense that they don't generally require you to specify types of variables, parameters, or return values; since these things aren't checked until the program runs, the tools necessary to convey type information to the compiler aren't required.  Dynamically-typed languages often have more flexible semantics, because your uses of types aren't limited by what your compiler will allow you to say, though some statically-typed languages provide more flexibility than others.  (C++, in this sense, is actually very flexible, but at the cost of having a fair amount of syntactic complexity; we'll see that much later in the quarter.)</p>

<p>Depending on what language(s) you've learned previously, static type checking may be exactly what you expected or it may seem out-of-the-ordinary, but it's our reality in C++ and we'll need to embrace it.</p>

</div>

<div class="section">

<hr />

<p class="title">A slightly more full-featured example</p>

<p>Let's add some code to our <b>main()</b> function so that it has a visible effect when we run it.  In particular, let's write a program that writes something to the standard output (so, for example, if we run the program from a shell prompt in Linux, we'll see the output in the shell).</p>

<blockquote><pre>
#include &lt;iostream&gt;

int main()
{
    std::cout &lt;&lt; "Hello Boo!" &lt;&lt; std::endl;
    return 0;
}
</pre></blockquote>

<p>There are a few notable things going on in this example:</p>

<ul>
  <li>The line beginning with <b>#include</b> is called a <i>preprocessor directive</i>.  Preprocessor directives begin with <b>#</b> characters.  For now, you can think of the <b>#include</b> directive as loading a library; in this case, the library we're loading is part of the C++ Standard Library (we can tell that it's not part of our code because its name is surrounded by angle brackets) and its name is <b>iostream</b>, which gives us the ability to manipulate <i>streams of input or output</i>.</li>
  <li>Things that are defined in the C++ Standard Library generally have names that begin with <b>std::</b>.  In this case, <b>std</b> is what's called a <i>namespace</i>.  In this course, when we use things that are defined in namespaces, we'll use their full names (including the names of their namespaces), so we can more easily distinguish between things that are standard and things that we wrote ourselves.  (This kind of careful differentiation becomes much more important as programs become larger, even if it seems nonsensical in short, simple examples like these.)</li>
  <li><b>std::cout</b> is an object called an <i>output stream</i>; in particular, it is the one that represents the program's <i>standard output</i>.  Whatever gets written into it will be written to the program's standard output channel.  If we run a program from a shell prompt in Linux, for example, then we would see all of that output appear in the shell.  You can <i>put</i> data into an output stream by using the <b>&lt;&lt;</b> operator (which is often called the "put operator").  Note, too, that we can string together several uses of <b>&lt;&lt;</b>, so that we can easily write a sequence of things into the same output stream in a single expression.</li>
  <li><b>"Hello Boo!"</b> is a <i>string literal</i>, i.e., a literal sequence of characters of text.  String literals follow similar rules in C++ as they do in many other programming languages, though one thing to note in C++ is that they must always be surrounded by double-quotes, as opposed to being surrounded by single-quotes or something else.</li>
  <li><b>std::endl</b> is an object that represents a platform-independent end-of-line sequence.  For our work, it's a good idea to use this instead of something like <b>"\n"</b>, since end-of-line sequences are different on different operating systems.  (There are other considerations, such as low-level performance details, but these are beyond the scope of our work here.  We'll pick our battles, keeping things simple when we can.)</li>
</ul>

<p>With those things in mind, we can see that executing this program would cause <b>Hello Boo!</b> to be written to the program's standard output, and then the program's exit code would be 0.</p>

</div>

<div class="section">

<hr />

<p class="title">Basic built-in data types</p>

<p>C++ has a set of basic, built-in data types that are available in all programs without doing anything special.  They're not part of a library, but are instead intrinsic to the language.  A non-exhaustive list of those built-in types follows.</p>

<ul>
  <li><i>Integral types</i>, which represent integer values.  Interestingly, there are multiple integral types in C++, not just one, differing on the basis of <i>how much memory</i> is used to represent a value of each type.  The common examples are: <b>int</b>, <b>long</b>, <b>long long</b>, <b>short</b>, and <b>char</b>.  The size of a value of each type is specific to the platform you're using (e.g., the operating system, the compiler, and so on), as opposed to being standard.  The only thing you can truly count on from one platform to another is the following rule:
    <ul>
      <li><b>sizeof(char)</b> &leq; <b>sizeof(short)</b> &leq; <b>sizeof(int)</b> &leq; <b>sizeof(long)</b> &leq; <b>sizeof(long long)</b></li>
    </ul>
  On the ICS 45C VM we're using in this course, an <b>int</b> is 32 bits, with the available values split roughly evenly between positive and negative values, meaning that the range of possible values you can store in an <b>int</b> is -2,147,483,648 .. 2,147,483,647.  Strangely, both <b>long</b> and <b>long long</b> values on our platform are 64 bits, while <b>short</b>s are 16 bits, and <b>char</b>s are 8 bits.  On other platforms, these sizes may differ.</li>
  <li><i>Unsigned integral types</i>, which represent whole number values (i.e., they cannot be negative).  Each of the integral types has an unsigned variant, denoted by the word <b>unsigned</b> appearing in the name of its type.  So, for example, an <b>unsigned int</b> is (on our platform) a 32-bit whole number value, an <b>unsigned short</b> is a 16-bit whole number, and so on.</li>
  <li><b>bool</b>, a boolean type that has two possible values: <b>true</b> and <b>false</b>.  It turns out that <b>bool</b> values are freely exchangeable with integral values, for the most part, with 0 typically meaning <b>false</b> and anything non-zero meaning <b>true</b>.  I've found that it's generally wise to think of <b>bool</b> as being separate, and not to rely too much on the non-zero/zero dichotomy in the code I write, which can lead to obtuse-looking code that's harder to read and understand.  But you do need to understand that this is how C++ works, since you'll encounter code that makes use of this.</li>
  <li><i>Floating-point numbers</i>, which represent numeric values that can have a fractional part.  There are two such types built into C++: <b>float</b> and <b>double</b>, with the distinction being how many bits of <i>precision</i> they offer &mdash; more or less, how many significant digits are available, though the digits are binary as opposed to decimal.  The number of bits is different depending on the platform, but <b>sizeof(float)</b> &leq; <b>sizeof(double)</b>.  On our ICS 45C VM, a <b>float</b> is 32 bits and a <b>double</b> is 64 bits, meaning that <b>double</b> values are more precise to work with; we'll rarely see <b>float</b> values in this course, but you might use them, in practice, if you're more concerned about how much memory you're using than how much precision your results can be expressed with.</li>
</ul>

</div>

<div class="section">

<hr />

<p class="title">Expressions and statements</p>

<p>The bodies of functions are made up of <i>statements</i>, which can, in turn, contain <i>expressions</i>.  While you've almost certainly written programs in a language that draws a distinction between expressions and statements, you may never have actually had that distinction called out before, and you might not be aware of what these terms mean.  But they form an important part of understanding how C++ works, so we need to be sure we're clear on it.</p>

<p>An <i>expression</i> evaluates to a value, meaning that it also has a type.  Expressions are quite often built by combining smaller expressions.  The type of an expression is determined &mdash; at compile time! &mdash; based on the types of its subexpressions and the operators or other syntactic constructs used to combine them.  When the program runs, the value of the expression is determined by combining the values of the subexpressions.</p>

<p>An example of an expression with subexpressions would be <b>a + b</b>, which appears to be the addition of the variables <b>a</b> and <b>b</b>.  <b>a</b> and <b>b</b> are themselves subexpressions, and their types are governed by the types of the corresponding variables.  They're combined using the operator <b>+</b>, whose meaning actually depends on the types of <b>a</b> and <b>b</b>.  For example, if <b>a</b> and <b>b</b> are integers, this means that we want to add the two integers together and the value of the expression is their sum; if <b>a</b> and <b>b</b> are strings instead, then we want to concatenate the two strings together and the value of the expression is their concatenation.  Either way, since the compiler will always definitively know the types of <b>a</b> and <b>b</b>, the expression will have a definitive meaning before the program runs.</p>

<p>Statements perform a job, but do not themselves have a value (or a type).  Their primary role is to have a <i>side effect</i>, which is to say that executing them causes something to change.  The value of a variable may be changed, control flow in the program may be affected, input may be read from an input source, output may be written to an output source, a file may be created, a socket may be opened, or whatever.  Statements quite often contain expressions within them, and the values and types of those expressions affect what they do.</p>

<p class="subtitle">Expression statements, compound statements, and control structures</p>

<p>C++ provides the ability to write many kinds of statements that do a variety of things, which we'll see as we move forward.  The simplest kind of statement is an <i>expression statement</i>, which is simply an expression terminated with a semicolon:</p>

<blockquote><pre>
a + b;
</pre></blockquote>

<p>An expression statement simply evaluates its expression and then discards the value afterward.  That may seem silly &mdash; and, in many cases, it is! &mdash; but can be useful when an expression has a side effect, such as the assignment of a value into a variable:</p>

<blockquote><pre>
a = 3;
</pre></blockquote>

<p>Assignment is an expression in C++, and its value is (more or less) the value that was assigned (in this case, 3), but you'll most often see it appear as a stand-alone expression statement, because the side effect of changing the variable's value is the only effect that is desired.</p>

<p>A <i>compound statement</i>, also called a <i>block statement</i> or a <i>block</i>, is a sequence of statements surrounded by curly braces.  When a compound statement executes, the statements inside of it are executed in order, one after another.  Compound statements can appear anywhere, though we most often use them as the body of <i>control structures</i>.</p>

<p><i>Control structures</i> are statements that affect the <i>control flow</i> of a program (i.e., to affect what happens next, as opposed to the default behavior of one statement flowing straight through to the one after it).  C++ has a number of control structures, many of which are likely to look fairly familiar to you from whichever language(s) you've learned previously.</p>

<ul>
  <li><b>if</b> statements allow you to execute statements conditionally, based on the value of a <i>conditional expression</i>.
    <blockquote><pre>
if (a &lt; 3 &amp;&amp; b &gt; 9)
{
    std::cout &lt;&lt; "out of range" &lt;&lt; std::endl;
}
else
{
    std::cout &lt;&lt; "in range!" &lt;&lt; std::endl;
}</pre></blockquote>
  In this example, we'll either write <b>out of range</b> or <b>in range!</b> to the standard output, depending on whether it's true that <b>a</b> is less than 3 and <b>b</b> is greater than 9.  The conditional expression is the one written in parentheses just after the <b>if</b>, and there are a couple of things you should know about it that might surprise you:
    <ul>
      <li>The parentheses are part of the syntax, so they are not optional in this case.  The conditional expression must appear in parentheses.</li>
      <li>The body of an <b>if</b> statement and any <b>else if</b> or <b>else</b> branches is actually made up of a single statement, though that single statement can be a block statement, as I've used here.  I generally always use blocks, which aids in readability and maintainability.  (As an aside, you may already have noticed that this is a recurring theme, that we're more interested in how hard it is to read, understand, and maintain a program over the long haul than how much we have to type in order to write it.  This is for good reason: You'll spend more time reading and understanding most programs than you will writing them, and this is especially true for programs whose lifespans are longer than a university assignment.)</li>
      <li>While we quite often write conditional expressions that are boolean in nature, they can technically be anything integral, where zero is treated as false and <i>anything non-zero</i> is treated as true.  This can lead to some very obscure-looking code, so we'll do our best to avoid this, by writing conditional expressions that are explicitly boolean (e.g., <b>a != 0</b> instead of <b>a</b>, even though both technically have the same meaning if <b>a</b> is an integer).</li>
    </ul>
  </li>
  <li><b>switch</b> statements provide another, more limited form of conditionality, where you execute one sequence of statements or another based on the value of a <i>controlling expression</i>.  An example follows:
    <blockquote><pre>
switch (a)
{
case 0:
    std::cout &lt;&lt; "zero" &lt;&lt; std::endl;
    break;

case 1:
    std::cout &lt;&lt; "one" &lt;&lt; std::endl;
    break;

default:
    std::cout &lt;&lt; "other" &lt;&lt; std::endl;
    break;
}</pre></blockquote>
  As with the conditional expression in an <b>if</b> statement, the controlling expression here must appear in parentheses, and it must be integral.  The actual meaning of this <b>switch</b> statement is not quite as it appears:
    <ul>
      <li>First, the controlling expression is evaluated.  In this case, let's suppose that the value of <b>a</b> is 1.</li>
      <li>Based on that value, the corresponding <b>case</b> is chosen.  The <b>default</b> case, if specified, is chosen when no other <b>case</b> matches.</li>
      <li>Once a case is chosen, the sequence of statements below it is executed until one of two things happens: the end of the <b>switch</b> statement is reached, or a <b>break</b> statement is reached.  (Note that this means that forgetting the <b>break</b> means that we would continue executing statements that comprise the next case.  For example, if there were no <b>break</b> statements in the <b>switch</b> statement above, and if <b>a</b>'s value was 1, we would see both <b>one</b> and <b>other</b> appear in the standard output.)</li>
    </ul>
  </li>
  <li>There are a few kinds of loops in C++.  We'll start with three of them, each of which is based around a <i>conditional expression</i> that follows the same rules as the <b>if</b> statement (i.e., non-zero is true, zero is false), and each of which determines whether to continue executing based on whether that conditional expression is true.  The three loop variants are shown below.
    <blockquote><pre>
int a = 3;      // <i>this is a variable declaration; more about this below</i>
while (a &lt; 10)
{
    std::cout &lt;&lt; a &lt;&lt; std::endl;
    a++;        // <i>adds 1 to a; more details later</i>
}


int a = 3;
do
{
    std::cout &lt;&lt; a &lt;&lt; std::endl;
    a++;
}
while (a &lt; 10);


for (int a = 3; a &lt; 10; a++)
{
    std::cout &lt;&lt; a &lt;&lt; std::endl;
}</pre></blockquote>
  These three kinds of loops are similar, but subtly different, so it's worth understanding the details.
    <ul>
      <li>In a <b>while</b> loop, the conditional expression is evaluated before each loop iteration (including the first), and stops executing when the conditional expression evalutes to false.</li>
      <li>In a <b>do..while</b> loop, the conditional expression is evaluated <i>after</i> each loop iteration, and stops executing when the conditional expression evaluates to false.  Note that this means that the body of a <b>do..while</b> loop will always execute at least once, which can make it useful in scenarios like reading user input with error checking, when you know at least one attempt will need to be made.</li>
      <li>The strangest-looking of the three is the <b>for</b> loop, which is actually a simplification of a common pattern for writing <b>while</b> loops.  What lies between the parentheses on the top line of a <b>for</b> loop consists of three parts, separated by semicolons: the <i>initialization expression</i>, the <i>conditional expression</i>, and the <i>iteration expression</i>.  When the <b>for</b> loop begins, its initialization expression is evaluated once.  Then the loop begins; like a <b>while</b> loop, the conditional expression is evaluated before each loop iteration.  The body of the loop is executed in each loop iteration, and after each one, the iteration expression is evaluated once.  Note that the <b>for</b> loop above and the <b>while</b> loop above are equivalent to one another.  We'll typically write <b>for</b> loops when this pattern is the right one, but we'll certainly need <b>while</b> loops in the many cases where it isn't.</li>
      </li>
    </ul>
  </li>
</ul>

</div>

<div class="section">

<hr />

<p class="title">Declarations</p>

<p>A <i>declaration</i> introduces a name into a C++ program.  The declaration associates that name with a type, which specifies how it can be used properly, and which gives the compiler the ability to check those uses at compile time to ensure that they're proper.  The goal of a declaration is to state that something exists and to give it a type, though it does not necessarily provide all of the other relevant details.</p>

<p>A few examples of declarations follow:</p>

<blockquote><pre>
int a;
double d = 3.0;
int square(int n);
</pre></blockquote>

<p>The first of these is the declaration of a <i>variable</i>.  Variables name a block of memory in which a value can be stored.  Note that variable declarations include not only a name, but also a type; for example, given the declaration of the variable <b>a</b> as an <b>int</b>, the compiler will ensure that only an integer value will ever be stored in <b>a</b>.</p>

<p>The second of these is also the declaration of a variable, but it is also initializes the variable's value at the same time.  (One important thing to note about variables: they are not initialized to anything in particular unless you assign a value into them, so after the declaration of <b>a</b> above, the value of <b>a</b> will be undefined, in the sense that there are no guarantees about what that value will be.  A subsequent use of that variable before assigning a value to it would be what is called <i>undefined behavior</i>, which means that we can't know what will happen next; we'll use tools later this quarter for detecting these kinds of mistakes.)</p>

<p>The third is the declaration of a <i>function</i>.  Note that it looks just like the signature of a function, but is terminated with a semicolon instead of being followed by a body.  The declaration of a function establishes that function's existence, but does not specify what the function does, which brings up the interesting question of why you would want to be able to do that.  Read on.</p>

<p class="subtitle">Why do we need declarations?</p>

<p>Declarations establish how a name can be used legally in a C++ program.  Since C++ performs static type checking, it needs to be aware of what the appropriate types will be; declarations serve this purpose.  Names in C++ must be declared <i>before use</i> (i.e., the declaration of a name must appear in a program before the first use of that name).  This is a bit different from many other programming languages, which cast a much less scrutinizing eye on the order in which you say things.</p>

<p>As a result of the rule requiring declaration before use, this function would be illegal:</p>

<blockquote><pre>
int main()
{
    a = 3;
    std::cout &lt;&lt; a &lt;&lt; std::endl;
    int a;
    return 0;
}
</pre></blockquote>

<p>because the variable <b>a</b> is not declared until after it's been used in a couple of ways.  Similarly, this function would be illegal, too:</p>

<blockquote><pre>
int main()
{
    a = 3;
    std::cout &lt;&lt; a &lt;&lt; std::endl;
    return 0;
}
</pre></blockquote>

<p>because <b>a</b> hasn't been declared at all.</p>

</div>

<div class="section">

<hr />

<p class="title">Definitions</p>

<p>A <i>definition</i> gives a declared name a unique, specific meaning; it "gives that name life," so to speak.  For example, the following code is a definition of a function <b>boo()</b>, because it not only specifies that the function exists, but also specifies what the function does.</p>

<blockquote><pre>
int boo()
{
    return 9999;
}
</pre></blockquote>

<p>Because it includes the function's signature, this definition would also serve as a declaration if the name <b>boo</b> had not yet been declared.</p>

<p>Some declarations are also definitions.  Variable declarations not only specify that a variable exists and give it a type, but they also cause memory to be allocated in which to store the variable's value.  In a sense, all there is to know about a variable, in order to "give it life," is the type, because the type dictates the amount of memory required to store it.  Note that variables can be initialized to a value when declared, as we've seen, but a variable declaration is also a definition whether you initialize its value or not; variables live even when they haven't had a value explicitly assigned to them.</p>

<p>Not all declarations are definitions.  A notable example is a function declaration, which specifies how a function can be called, without stating anything about what the function does.  (It should be noted that function declarations serve a bigger purpose than you might think, not only because names must be declared before use, but especially when we soon start writing programs that consist of more than one source file.)</p>

</div>

<div class="section">

<hr />

<p class="title">Assignments, lvalues, and rvalues</p>

<p>One very fundamental task in C++, as in many other programming languages, is the ability to store a value in a variable.  As we've seen above, <i>assignment</i> is a kind of expression that does just that.  The expression <b>a = 3</b> indicates that the value <b>3</b> should be stored into the variable <b>a</b>, subject to successful static type checking (i.e., <b>a</b> must be able to store an integral value, so it must be a type such as <b>int</b>).  In this case, <b>a</b> and <b>3</b> are subexpressions, and the <b>=</b> operator is used to connect the two subexpressions together.</p>

<p>Embedded within this seemingly simple assignment is an important concept in C++, which is the distinction between <i>lvalues</i> and <i>rvalues</i>.  Expressions can be thought of as evaluating to either an lvalue or an rvalue, and it's important to understand the difference.</p>

<p>Originally, the terms "lvalue" and "rvalue" took their names from the distinction between what is legal to put on the <b><i>l</i></b>eft- or <b><i>r</i></b>ight-hand side of an assignment expression, where an "lvalue" refers to an expression that would be legal on the left-hand side, while an "rvalue" refers to an expression that would <i>only</i> be legal on the right-hand side.  The following examples embody the concept at work here.  (Let's assume that the variables <b>a</b>, <b>b</b>, and <b>c</b> that appear below all have the type <b>int</b>.)</p>

<blockquote><pre>
a = 3       <i>// legal</i>
a = 3 + 4   <i>// legal</i>
a = b       <i>// legal</i>
a = b + c   <i>// legal</i>
3 = a       <i>// not legal</i>
b + c = a   <i>// not legal</i>
</pre></blockquote>

<p>While there is more nuance to these terms than we're seeing here, the assignments above provide the basic mental framework for understanding them.  An lvalue is a value that lives beyond the expression in which it is originally evaluated; variables certainly fit into that category, since their values can be used again later.  (A simple way to think about that is to think about whether an expression can be used to represent a location in memory; if so, it's an lvalue.)  An rvalue, on the other hand, is one that is temporary, i.e., that dies when the expression that generated it is finished being evaluated.  That's certainly true of the value of a constant, or the value of expressions like <b>3 + 4</b> or <b>b + c</b>, which calculate a result, but don't themselves store it anywhere.</p>

<p>C++ goes to the trouble of naming these concepts partly because they're not as simple as they sound.  As we'll see, not all lvalues are variable names.  For example, the result of a function call can be a location in memory, meaning that it can be used as an lvalue, leading to the following strange-looking but perfectly legal line of code:</p>

<blockquote><pre>
v.at(2) = 3;   <i>// what?!</i>
</pre></blockquote>

<p>Why we need to take the time to learn this distinction now is because terms like <i>lvalue</i> and <i>rvalue</i> show up in error messages that emanate from C++ compilers, and because they foreshadow concepts that will be very important from a performance perspective as we consider the use of memory more carefully going forward.</p>

<p>(It should be noted that things have become even more nuanced since C++11 introduced new features such as <i>move</i>, so there are more kinds of values nowadays than just lvalues and rvalues, but we'll stick with the simpler conceptual framework for now.)</p>

</div>

<div class="section">

<hr />

<p class="title">More about calling and declaring functions</p>

<p>As we've seen, a <i>function</i> is a sequence of statements that can be <i>called</i>, accepting a sequence of <i>parameters</i>, and returning a result.  Particularly because of the importance of types &mdash; and the fact that they're statically checked &mdash; functions must be declared before they're called; the declaration specifies not only the existence of the function, but also the types of parameters and the type of its return value.</p>

<p>So, given this idea, we could write the definition of a function <b>square()</b> that takes an integer value and squares it.</p>

<blockquote><pre>
int square(int n)
{
    return n * n;
}
</pre></blockquote>

<p>Since function definitions include a signature, they also act as declarations, which would make the following program legal:</p>

<blockquote><pre>
#include &lt;iostream&gt;

int square(int n)
{
    return n * n;
}

int main()
{
    std::cout &lt;&lt; square(4) &lt;&lt; std::endl;
    return 0;
}
</pre></blockquote>

<p>The call to <b>square()</b> in <b>main()</b> is legal, because I've passed one <i>argument</i> that is an integer.  The arguments listed when a function is called, in general, are matched up with the function's parameters in the order listed, with the type of each argument required to be compatible wtih the corresponding parameters.</p>

<p>Note, too, that order is important here: Since <b>square()</b> is defined before <b>main()</b>, it was legal to call <b>square()</b> from within <b>main().</b>  But the reverse order would be problematic:</p>

<blockquote><pre>
#include &lt;iostream&gt;

int main()
{
    std::cout &lt;&lt; square(4) &lt;&lt; std::endl;
    return 0;
}

int square(int n)
{
    return n * n;
}
</pre></blockquote>

<p>The call to <b>square()</b> in <b>main()</b> would be deemed illegal by the compiler, because it precedes any declaration of the function.</p>

<p>But remember that functions can be declared without being defined, so that opens up a third possibility that would be legal:</p>

<blockquote><pre>
#include &lt;iostream&gt;

int square(int n);

int main()
{
    std::cout &lt;&lt; square(4) &lt;&lt; std::endl;
    return 0;
}

int square(int n)
{
    return n * n;
}
</pre></blockquote>

<p>While this style &mdash; declaring a function earlier and defining it later in the same source file &mdash; isn't particularly better than the first, it's important to understand that either of these is legal, because when we start writing programs that span multiple source files, this technique will become vital.  (First, you have to understand how things work; then you can focus on how to use these techniques to good end.)</p>

</div>

<div class="section">

<hr />

<p class="title">More about function return values, and the importance of heeding warnings</p>

<p>Most C++ functions return a single value of some type.  While the idea that only one value can be returned sounds restrictive, it's important to realize that there are plenty of data types more complex than <b>int</b>, and that we'll be able to define our own data types.  So this restriction is quite workable in practice.</p>

<p>When you write a function that is said to return a value, you'll want to be absolutely sure that <i>every path</i> through the function's statements reaches a <b>return</b> statement.  While it is technically legal in C++ to write functions that don't explicitly return a value when they should, a well-configured compiler will at least generate what's called a <i>warning</i>, which will alert you to the very likely possibility that you have a bug.  Warnings, generally, are messages emanating from your compiler that indicate the presence of a potential problem in code that is otherwise technically legal.  For the most part, when you get a warning, it's indicating an issue you should be paying attention to; it's rare (though not unheard of) that warnings can safely be ignored.</p>

<p>For example, consider this function:</p>

<blockquote><pre>
int absoluteValue(int n)
{
    if (n < 0)
    {
        return -n;
    }
}
</pre></blockquote>

<p>At a glance, this function appears to do the important thing, which is to negate a negative input so that it becomes positive.  However, consider what the function does when given a non-negative input.  The conditional expression in the <b>if</b> statement will evaluate to <b>false</b>, but since there is no <b>else</b> branch, the function will not reach a <b>return</b> statement.  So what does the function return in this case?</p>

<p>Interestingly, the above function will actually compile successfully &mdash; on a typical compiler, you'll receive a warning about not every path through the function leading to a <b>return</b> statement, but since this is not technically illegal in C++, you won't necessarily get an error.  But its behavior will be undefined if you call it with anything except a negative input.  For fun, I wrote this short <b>main()</b> function to exercise this scenario:</p>

<blockquote><pre>
int main()
{
    std::cout << absoluteValue(-3) << std::endl;
    std::cout << absoluteValue(3) << std::endl;
    return 0;
}
</pre></blockquote>

<p>When I ran this program on the ICS 45C VM, it first displayed <b>3</b> on the standard output (because <b>absoluteValue(-3)</b> returned <b>3</b>) and then crashed.  On another environment, the outcome might have been different &mdash; a seemingly random "garbage" value being printed, for example &mdash; but, importantly, it would never have worked consistently.</p>

<p>Your programs in this course will be expected to compile both without errors <i>and without warnings</i>, because, in our exprience, compiler warnings are almost always an indication of a program bug, or, at least, something that could be written more clearly.  And once you begin to allow compiler warnings to creep into a project, to the point where you see many of them every time you compile your program, you'll no longer notice when new warnings show up that you didn't see the last time, so you'll begin to miss what they're trying to tell you.  To enforce this, the compiler on the ICS 45C VM has been configured to <i>treat all warnings as though they were errors</i>, so that no program can be compiled successfully and run if it causes any warnings to be emitted.</p>

<p>Of course, the fix in this particular case is quite simple: Make sure that every path through the function leads to a <b>return</b> statement that returns a value of type <b>int</b>.  One way to write that, using techniques we've seen, is below.</p>

<blockquote><pre>
int absoluteValue(int n)
{
    if (n < 0)
    {
        return -n;
    }
    else
    {
        return n;
    }
}
</pre></blockquote>

<p class="subtitle">Functions that do not return a value</p>

<p>Note, too, that it is possible to write functions that do not return a value at all.  You can do this by writing a function whose return type is listed as <b>void</b>.  Such functions are generally useful for providing some kind of side effect (such as writing output):</p>

<blockquote><pre>
void printSquare(int n)
{
    std::cout &lt;&lt; n * n &lt;&lt; std::endl;
}
</pre></blockquote>

<p>In these functions, you can write a <b>return</b> statement with no value, but it is not required; reaching the end of the function is sufficient to end its execution cleanly, so I only write <b>return</b> statements in <b>void</b>-returning functions when I need to bail out of them early.</p>

</div>

</body>
</html>
Mis_redirected¢DtypeEvalueıIhttp_code¢DtypeEvalue»Qdownload_complete¢DtypeEvalueı