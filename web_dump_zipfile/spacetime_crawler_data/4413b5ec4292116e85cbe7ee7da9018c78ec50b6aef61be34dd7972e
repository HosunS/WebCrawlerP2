¦Ifinal_url¡DtypeLhttp_headers¢DtypeEvalue‰¢Ak¢DtypeEvalueNContent-LengthAv¢DtypeEvalueC874¢Ak¢DtypeEvaluePContent-EncodingAv¢DtypeEvalueDgzip¢Ak¢DtypeEvalueMAccept-RangesAv¢DtypeEvalueEbytes¢Ak¢DtypeEvalueDVaryAv¢DtypeEvalueOAccept-Encoding¢Ak¢DtypeEvalueFServerAv¢DtypeEvalueX4Apache/2.4.6 (CentOS) OpenSSL/1.0.2k-fips SVN/1.7.14¢Ak¢DtypeEvalueMLast-ModifiedAv¢DtypeEvalueXMon, 12 Mar 2018 23:07:46 GMT¢Ak¢DtypeEvalueDETagAv¢DtypeEvalueX"69e-5673f35ce88af-gzip"¢Ak¢DtypeEvalueDDateAv¢DtypeEvalueXThu, 31 Jan 2019 03:02:07 GMT¢Ak¢DtypeEvalueLContent-TypeAv¢DtypeEvalueXtext/html; charset=UTF-8Kraw_content¢DtypeEvalueYž<!DOCTYPE html>
<html>
<head>
<title>CompSci 261, Winter 2018, Homework 7</title>
<meta name="viewport" content="width=device-width, initial-scale=1">
<script type="text/x-mathjax-config">
MathJax.Hub.Config({
  tex2jax: {inlineMath: [['$','$'], ['\\(','\\)']]}
});
</script>
<script src="//cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>
</head>
<body>
<h1>CompSci 261, Winter 2018, Homework 7</h1>
<ol>

<li><p>Construct a Cartesian tree for the sequence 10 3 9 2 8 6 1 5 4.</p></li>

<li><p>Give the sequence of depths in the Euler tour for the Cartesian tree from your answer to question 1. If we wished to find the minimum value in the subsequence 3 9 2 8 (from the second to fifth positions in the original sequence) which subsequence of the Euler tour depth sequence would this query translate to?</p></li>

<li><p>In an unrooted tree (a connected undirected graph with no cycles) the median $m(a,b,c)$ of three vertices $a$, $b$, and $c$ is the unique tree vertex that lies on each of the three shortest paths between the three pairs of nodes. Describe how to use lowest common ancestors to design a data structure that can represent an unrooted tree in $O(n)$ space and answer median queries in $O(1)$ time.</p></li>

<li><p>Suppose that you wish to perform lowest common ancestor queries in rooted tree $T$, but that it has been stored in a data structure that can only answer level ancestor queries (given as arguments a vertex of $T$ and a depth $d$ of the ancestor to be found) in time $O(1)$ per query. Describe how to answer a lowest common ancestor query using $O(\log n)$ level ancestor queries.</p></li>

</ol>
</body>
</html>
Mis_redirected¢DtypeEvalueôIhttp_code¢DtypeEvalueÈQdownload_complete¢DtypeEvalueõ