¦Ifinal_url¡DtypeLhttp_headers¢DtypeEvalue‡¢Ak¢DtypeEvalueNContent-LengthAv¢DtypeEvalueD1112¢Ak¢DtypeEvalueMAccept-RangesAv¢DtypeEvalueEbytes¢Ak¢DtypeEvalueFServerAv¢DtypeEvalueXjApache/2.4.6 (CentOS) OpenSSL/1.0.2k-fips SVN/1.7.14 Phusion_Passenger/4.0.53 mod_perl/2.0.10 Perl/v5.16.3¢Ak¢DtypeEvalueMLast-ModifiedAv¢DtypeEvalueXWed, 17 Apr 2013 01:53:30 GMT¢Ak¢DtypeEvalueDETagAv¢DtypeEvalueS"458-4da84c0adda80"¢Ak¢DtypeEvalueDDateAv¢DtypeEvalueXThu, 31 Jan 2019 00:43:53 GMT¢Ak¢DtypeEvalueLContent-TypeAv¢DtypeEvalueXtext/plain; charset=UTF-8Kraw_content¢DtypeEvalueYX/*
  $Id: range.h 5713 2010-09-09 03:11:22Z abehm $

  Copyright (C) 2010 by The Regents of the University of California
 
  Redistribution of this file is permitted under the terms of the BSD
  license.

  Date: 07/19/2008
  Author: Rares Vernica <rares (at) ics.uci.edu>
*/

#ifndef _range_h_
#define _range_h_

#include <iterator>

template<class T>
struct range
{
  T _begin, _end;

  range(const T& begin = T(), const T& end = T()): 
    _begin(begin), 
    _end(end)
  {}
  
  template<class U>
  range(const range<U>& p):
    _begin(p._begin), _end(p._end)
  {}

  size_t size()
    const
  { return std::distance(_begin, _end); }

  const T& begin() const 
  { return _begin; }

  const T& end() const 
  { return _end; }

  typedef T iterator;
  typedef T const_iterator;
};

template<class T>
inline bool operator==(const range<T>& x, const range<T>& y) 
{ return x._begin == y._begin && x._end == y._end; }

template<class T> 
inline bool operator!=(const range<T>& x, const range<T>& y)
{ return !(x == y); }

template<class T>
inline range<T> make_range(T x, T y) { return range<T>(x, y); }

#endif
Mis_redirected¢DtypeEvalueôIhttp_code¢DtypeEvalueÈQdownload_complete¢DtypeEvalueõ