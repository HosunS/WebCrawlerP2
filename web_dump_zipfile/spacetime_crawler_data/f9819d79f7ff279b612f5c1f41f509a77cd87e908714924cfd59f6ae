¦Ifinal_url¢DtypeEvaluex:https://www.ics.uci.edu/~thornton/ics45c/Notes/Structures/Lhttp_headers¢DtypeEvalue‡¢Ak¢DtypeEvalueNContent-LengthAv¢DtypeEvalueE21871¢Ak¢DtypeEvalueMAccept-RangesAv¢DtypeEvalueEbytes¢Ak¢DtypeEvalueFServerAv¢DtypeEvalueX4Apache/2.4.6 (CentOS) OpenSSL/1.0.2k-fips SVN/1.7.14¢Ak¢DtypeEvalueMLast-ModifiedAv¢DtypeEvalueXMon, 14 Jan 2019 23:38:47 GMT¢Ak¢DtypeEvalueDETagAv¢DtypeEvalueT"556f-57f738bcd2fc0"¢Ak¢DtypeEvalueDDateAv¢DtypeEvalueXSun, 03 Feb 2019 12:17:25 GMT¢Ak¢DtypeEvalueLContent-TypeAv¢DtypeEvalueXtext/html; charset=UTF-8Kraw_content¢DtypeEvalueYUo<?xml version="1.0" encoding="iso-8859-1"?>
<!DOCTYPE html PUBLIC
 "-//W3C//DTD XHTML 1.1//EN"
 "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">

<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en">

<head>
<meta http-equiv="content-type" content="text/html; charset=iso-8859-1" />
<link rel="stylesheet" href="../../course.css" type="text/css" />

<title>ICS 45C Winter 2019, Notes and Examples: Structures</title>

</head>

<body>

<div class="navbar">

<p>
ICS 45C Winter 2019 |
<a href="../../index.html">News</a> |
<a href="../../CourseReference.html">Course Reference</a> |
<a href="../../Schedule.html">Schedule</a> |
<a href="../../ProjectGuide">Project Guide</a> |
<a href="../../Notes">Notes and Examples</a> |
<a href="http://www.ics.uci.edu/~thornton/">About Alex</a>
</p>

<hr />

</div>

<div class="header">

<p>ICS 45C Winter 2019<br />
   Notes and Examples: Structures</p>

</div>

<div class="section">

<p class="center"><i>Includes a code example with the moniker <b>Structures</b></i></p>

</div>

<div class="section">

<hr />

<p class="title">Background</p>

<p>Just as we have a need for <i>homogeneous data structures</i> &mdash; collections of some number of elements of the same type &mdash; there is also a common need for <i>heterogeneous data structures</i>, where we bring together multiple values of potentially different types into a single entity.  Ideally, these values have names that differentiate them from one another in a readable, meaningful way, though there are sometimes other ways to access them (e.g., tuples in Python, whose values are accessed by an index).</p>

<p>Once we pull together related data of different types into a single object, we can now access all of it using a single variable, pass it to a function with a single argument, and so on.  This can be a very big benefit, relative to the alternative of storing many variables and passing many parameters; a program is more readable if we can establish a single, simple name for a concept, even one that's more complex than built-in types like <b>int</b>s or <b>double</b>s.</p>

</div>

<div class="section">

<hr />

<p class="title">What are structures?</p>

<p>The simplest solution to a problem like this in C++ is to use something called a <i>structure</i> &mdash; generally called a <i>struct</i>, in line with the syntax used to declare them.  (There are fuller solutions to this problem, which we'll see soon, but we're starting with the raw materials and working our way up, so structures are a good place for us to start.)  A struct brings together a set of <i>members</i> (or, more specifically, <i>member variables</i>).  Each member variable has both a name and a type, with the names specifying how each of them is to be accessed or modified, and the types specifying what can and can't be stored in (and done to) each of them.</p>

<p>As a quick example, consider the following struct that represents a calendar date.  (Aside: I wouldn't generally implement dates this way, except perhaps in "last mile" code in a user interface, because dates are a fair bit more complicated than just being three integers.)  This is a <i>declaration</i> of that struct; remember that declarations specify the existence of something (in this case, a type called Date, which is a struct containing three unsigned integers) without concretely giving it life (i.e., without creating a variable of the new type).</p>

<blockquote><pre>
struct Date
{
    unsigned int year;
    unsigned int month;
    unsigned int day;
};
</pre></blockquote>

<p>Note the semicolon at the end of the declaration.  That's no joke; it has to be there!  Without it, you may find yourself getting some fairly strange-looking error messages out of a C++ compiler, which may be focused on the things that directly follow the struct declaration rather than the source of the problem.  (The reason why the semicolon has to be there is a bit of a long story, due to the history of the syntax of C, which allowed a struct declaration to be followed directly by the name of one or more variables that would take on that struct's type.  The semicolon is necessary so the compiler knows that you don't intend to do that.)</p>

<p>Before we go too far with this, it's important to reiterate that this is one way in C++ to create a new data type.  There is a new type in our program called <b>Date</b>, and C++ doesn't draw a meaningful distinction between built-in types like <b>int</b> and the types we create; all data types are on a fairly equal playing field.  (This is different than you might expect, especially if you've programmed in Java before, where "objects" are distinguished clearly from values of "primitive types."  C++ lacks this distinction altogether; even <b>int</b>s are "objects" in the C++ sense.)</p>

</div>

<div class="section">

<hr />

<p class="title">Statically allocating a struct</p>

<p>Once you've declared a struct, you've created a new data type, which means that you should now be able to instantiate it &mdash; meaning that you should be able to create variables of the new type.  As with variables of built-in types like <b>int</b>, you have your choice about where the variables should be allocated, the most common two choices being statically-allocated on the run-time stack or dynamically-allocated on the heap.  Given that Date structs are relatively small, we should tend to prefer them to be statically allocated, though it's sometimes unavoidable that we'll need them to be dynamically allocated instead (e.g., when their lifetime doesn't match the lifetime of some function), so we should know how to do both.</p>

<p>Statically allocating a Date struct on the run-time stack is just like declaring an <b>int</b> variable.</p>

<blockquote><pre>
void foo()
{
    Date d;
    ...
}
</pre></blockquote>

<p>The compiler is able to determine how much memory is required for the struct by deciding on a <i>layout</i> of its members.  The members are laid out in sequence, one after another (though sometimes with empty space called <i>padding</i> intentionally left between them, added to align the values in memory so they can be accessed more efficiently).  On the ICS 45C VM, unsigned integers are four bytes, so we might expect a Date struct to be 12 bytes, four for each of the unsigned integer members.  Because of this, the struct is no more expensive &mdash; in terms of time or memory &mdash; than having three separate unsigned int variables, which means we don't have to worry that we're costing ourselves performance to achieve an abstraction that otherwise simplifies our program.  Being able to do this is all upside.</p>

<p>Having declared a Date variable as above, its members' values will be initialized in whatever way is normal for the members' types.  A Date contains three unsigned integers; unsigned integers are not necessarily initialized automatically (e.g., they may take on whatever value was in memory previously) so the Date begins its life with undefined values stored in it.  We can set the members to new values individually by name, using the "." operator.</p>

<blockquote><pre>
void foo()
{
    Date today;
    today.year = 2016;
    today.month = 10;
    today.day = 2;
    ...
}
</pre></blockquote>

<p>We can read the "." to mean "The thing on the left has members and I'd like to access the member named on the right."  So, for example, <b>today.year</b> indicates that we believe <b>today</b> to be an object with members (it is!) and that we'd like to access its <b>year</b> member (which it has!).  Since the compiler is aware of the layout of the struct &mdash; not only the names of the members, but their relative positions in memory inside of it &mdash; it will know precisely where to go.  <b>today.year</b> is an lvalue (i.e., it has a storage location), so we can assign to it or read from it.</p>

<p>Alternatively, we can initialize a struct's members at the point where we create it using C++'s <i>uniform initialization</i> syntax &mdash; which, as we'll see, standardizes the way that objects of most types can be initialized.</p>

<blockquote><pre>
void foo()
{
    Date today{2016, 10, 2};
    ...
}
</pre></blockquote>

<p>The construct <b>{2016, 10, 2}</b> is called an <i>initializer list</i>, which specifies a sequence of values that are to be used to initialize <b>today</b>.  Using an initializer list with a struct causes the struct's members to be initialized in the order they're declared in the struct declaration &mdash; so, <b>year</b>, then <b>month</b>, then <b>day</b>.

<p>Note that there are a couple of consequences of using initializer lists in this way.  One consequence is that a change in the order of the members in the struct declaration might radically change how your code behaves without you receiving a compile-time error.  Another is that you've removed the members' names from your point in your code where initialization happens, which can sometimes make it harder for a program to read; you could argue that it's fairly clear what <b>2016</b>, <b>10</b>, and <b>2</b> are intended to be here, but even a simple case like this isn't entirely obvious, since dates are typically written with their components in different orders in different parts of the world.  A middle ground called <i>designated initializers</i> will be introduced in C++20, which would allow you to name the members you're initializing.</p>

<blockquote><pre>
void foo()
{
    // Not legal yet, but will be legal in C++20
    Date d{.year = 2016, .month = 10, .day = 2};
    ...
}
</pre></blockquote>

<p class="subtitle">What happens when a statically-allocated struct is deallocated</p>

<p>When a statically-allocated struct falls out of scope, it is destroyed automatically, taking its members with it.  Note, though, that if its members are pointers, the pointers will be destroyed, <i>but the objects the pointers point to will not!</i>  In this sense, the members of a struct are destroyed the same way that separate variables of the same types would be destroyed.</p>

</div>

<div class="section">

<hr />

<p class="title">Dynamically allocating a struct</p>

<p>Structs can also be allocated dynamically, as well, using the same <b>new</b> operator that we've seen previously.  As before, the <b>new</b> operator returns a pointer to the newly-allocated struct.</p>

<blockquote><pre>
Date* d = new Date;
</pre></blockquote>

<p>In this case, 12 bytes will be allocated on the heap and a pointer to the 12-byte block will be returned.</p>

<p>Accessing the members of a struct through a pointer is a little bit trickier.</p>

<blockquote><pre>
d.year = 2005;     // Illegal, because d is a pointer; it has no member called <b>year</b>
*d.year = 2005;    // Also illegal, because "." has a higher precedence than "*"
(*d).year = 2005;  // Legal, but ugly as sin!
</pre></blockquote>

<p>Only the last of these says what we actually mean: "Go to where <b>d</b> (a Date pointer) points and <i>then</i> access its <b>year</b> member."  But it's a really unfortunate piece of syntax, because it's ugly and error-prone.  So C++ includes another operator, the "arrow" operator (-&gt;) that means the same thing: "The thing on the left is a pointer to an object with members.  Go to where it points and <i>then</i> access the member named on the right."</p>

<blockquote><pre>
d-&gt;year = 2005;    // Much nicer!
</pre></blockquote>

<p>Similar to statically-allocated structs, you can use an initializer list to give values to the struct's members at the time of creation.</p>

<blockquote><pre>
Date* d = new Date{2016, 10, 2};
</pre></blockquote>

<p class="subtitle">What happens when a dynamically-allocated struct is deallocated</p>

<p>As with other dynamically-allocated objects, we'll need to deallocate the struct when we're done with it.  We do this the same way that we deallocate other dynamically-allocated objects, by using the <b>delete</b> operator.</p>

<blockquote><pre>
delete d;
</pre></blockquote>

<p>The Date object will be deleted, taking its members with it, but note again that if any members are pointers, the pointers will be destroyed, but <i>the objects the pointers point to will not!</i>  If you want to delete those, that'll be up to you, and you'll need to do it before you destroy the struct containing those pointers.</p>

</div>

<div class="section">

<hr />

<p class="title">Passing structs as parameters</p>

<p>A struct can be passed to a function in the same ways that an <b>int</b> can: by value (meaning that a <i>copy</i> of the struct is passed), by reference (meaning that a reference to the struct is passed, so changes to the struct inside the function take effect in the caller), and so on.  Pass by value offers the guarantee of <i>value semantics</i> (changes inside the function do not affect the caller), though this can be expensive if the struct is large, so in those cases, we might prefer passing the struct by reference (with <b>const</b>, if we want to protect the caller's struct from being changed).</p>

<p>Syntactically, passing a struct as a parameter is unsurprising.</p>

<blockquote><pre>
void foo(Date d)
{
    // d is a copy of the struct passed as a parameter
}

void bar(Date& d)
{
    // modifications to d take effect in the caller
}

var baz(const Date& d)
{
    // d is not a copy, but it can't be modified
}
</pre></blockquote>

</div>

<div class="section">

<hr />

<p class="title">More about how structs are laid out in memory</p>

<p>Given a struct declaration, a C++ compiler needs to decide on a <i>layout</i> for its members, which is to say it'll have to decide two things:</p>

<ul>
  <li>How much memory will be used to store one instance of the struct?</li>
  <li>Where, within that amount of memory, will each of the struct's members be stored?</li>
</ul>

<p>The answer to these questions should be the same for every instance of the struct, because the compiler will have to emit code that allocates them, manipulates them, passes them as parameters, and so on.  So, for example, let's consider this short function:</p>

<blockquote><pre>
void foo()
{
    Date d;
    d.year = 2005;
    d.month = 11;
    d.day = 1;
    std::cout &lt;&lt; d.year &lt;&lt; '-' &lt;&lt; d.month &lt;&lt; '-' &lt;&lt; d.day &lt;&lt; std::endl;
}
</pre></blockquote>

<p>When the compiler is deciding on the layout for <b>foo()</b>'s activation record, it'll need to know how big a <b>Date</b> object is.  When it needs to emit code that accesses the <b>year</b>, <b>month</b>, and <b>day</b> fields, it'll need to know where they are within the <b>Date</b> object that's been allocated on the run-time stack.</p>

<p>As with many such details, there are no hard-and-fast rules; they're left loosely defined, so compiler implementers can emit code that is the most efficient (in terms of memory usage or time, which are quite often traded off against one another).  But there are some aspects of struct layout that are well-defined, even if the details are left open.</p>

<p>C++ guarantees that a struct's members will be laid out in memory one after another, in the order declared.  That means the minimum size of a <b>Date</b> struct would be the sum of the sizes of its members.  Since a <b>Date</b> struct has three <b>unsigned int</b> members and, on the ICS 45C VM, <b>unsigned int</b>s are four bytes each, a <b>Date</b> object will be at least 12 bytes.  If we're curious, we could find out by running this code:</p>

<blockquote><pre>
std::cout &lt;&lt; sizeof(Date) &lt;&lt; std::endl;
</pre></blockquote>

<p>and, indeed, on the ICS 45C VM, this will print <b>12</b>, though you might get different output on a different compiler or a different operating system.</p>

<p>It's not always the case that struct members are crammed into memory as tightly as possible.  Consider instead this struct declaration:</p>

<blockquote><pre>
struct X
{
    char a;
    int b;
    short s;
    double d;
};
</pre></blockquote>

<p>On the ICS 45C VM, I declared this struct and then ran the following code to gather more information about the struct's layout in memory.</p>

<blockquote><pre>
X example;
std::cout &lt;&lt; sizeof(example.a) &lt;&lt; std::endl;
std::cout &lt;&lt; sizeof(example.b) &lt;&lt; std::endl;
std::cout &lt;&lt; sizeof(example.c) &lt;&lt; std::endl;
std::cout &lt;&lt; sizeof(example.d) &lt;&lt; std::endl;
std::cout &lt;&lt; sizeof(X) &lt;&lt; std::endl;
</pre></blockquote>

<p>The sizes of the individual members mirror the sizes of the corresponding built-in types: <b>a</b> is 1 byte, <b>b</b> is 4 bytes, <b>c</b> is 2 bytes, and <b>d</b> is 8 bytes.  This might lead one to believe that the size of an <b>X</b> struct is 1 + 4 + 2 + 8 = 15 bytes.  However, the last line of output tells a different story; the size of an <b>X</b> struct is listed as <b>24</b>!  So what's going on here?</p>

<p>On many processor architectures, memory accesses are significantly faster if they are done on appropriate boundaries.  While the rules below are hypothetical, they're not entirely uncommon in reality.</p>

<ul>
  <li>Accessing any single byte is generally about as fast as accessing any other one.</li>
  <li>Accessing two bytes is best done on a two-byte boundary (i.e., a memory address that is a multiple of 2).</li>
  <li>Accessing four bytes is best done on a four-byte boundary (i.e., a memory address that is a multiple of 4).</li>
  <li>Accessing eight bytes is best done on a eight-byte boundary (i.e., a memory address that is a multiple of 8).</li>
</ul>

<p>Consider, then, where the members of an <b>X</b> would be stored if one was placed immediately after another:</p>

<ul>
  <li><b>a</b> would be at the beginning of the struct (i.e., at an offset of 0 bytes from the beginning)</li>
  <li><b>b</b> would be just after <b>a</b>, so at an offset of 1 byte from the beginning, since <b>a</b> is 1 byte</li>
  <li><b>c</b> would be just after <b>b</b>, so at an offset of 5 bytes from the beginning, since <b>b</b> is 4 bytes</li>
  <li><b>d</b> would be just after <b>c</b>, so at an offset of 7 bytes from the beginning, since <b>c</b> is 2 bytes</li>
</ul>

<p>The problem is that accessing the four-byte value of <b>b</b>, the two-byte value of <b>c</b>, and the eight-byte value of <b>d</b> would all be significantly slower than they need to be, because none of them are aligned on a proper boundary.  So C++ compilers quite often introduce <i>padding</i> into a structure, bytes that are intentionally left unused, but that serve to improve access speeds to the individual members by placing them at the appropriate boundaries.  Since not all architectures have the same rules for this, there is no standard way that C++ pads structures &mdash; and many compilers let you turn this feature off, selectively for individual structs, if you're more interested in saving memory or aligning things in particular places (e.g., if you're communicating with hardware that requires a very particular layout) than you are in access speed.</p>

<p>So the reason that the size of an <b>X</b> struct is 24 bytes is because of padding introduced into it.  If we're really curious about where the padding is, we could even print out the addresses of individual members and see where they are in relation to each other, then use that to deduce where the padding is.  For example:</p>

<blockquote><pre>
std::cout &lt;&lt; &amp;example &lt;&lt; std::endl;
std::cout &lt;&lt; &amp;example.b &lt;&lt; std::endl;
std::cout &lt;&lt; &amp;example.c &lt;&lt; std::endl;
std::cout &lt;&lt; &amp;example.d &lt;&lt; std::endl;
</pre></blockquote>

<p>When I tried this on the ICS 45C VM, I was able to see that the members were aligned as follows:</p>

<ul>
  <li><b>a</b> is at offset 0 and has size 1</li>
  <li><b>b</b> is at offset 4 and has size 4</li>
  <li><b>c</b> is at offset 8 and has size 2</li>
  <li><b>d</b> is at offset 16 and has size 8</li>
</ul>

<p>So, out of the 24 bytes used to store an <b>X</b>, 9 of those bytes (3 after <b>a</b> and 6 after <b>c</b>) are padding.</p>

</div>

<div class="section">

<hr />

<p class="title">A disclaimer about structs</p>

<p>The actual rules in C++ differ a bit from what I've said here.  Structs are more capable than this &mdash; and, as we'll see, they are technically indistinguishable from another feature called classes, except in only the most minor ways &mdash; but, as a practical matter, structs are most often used in the way we've seen here; we'll use them to provide the ability to bring a set of public member variables together and nothing else.</p>

<p>We'll only be using structs in this way this quarter; whenever we want something more full-featured, we'll use classes instead.  (Note, too, that this is all structs can do historically; in C, there are no classes, while structs are limited, more or less, to what you see here.)</p>

</div>

<div class="section">

<hr />

<p class="title">The code</p>

<p>The official moniker for this code example is <b>Structures</b>, so your best bet is to do this:</p>

<ul>
  <li>Create a new project using the <b>example</b> project template.</li>
  <li>Change into the project directory.</li>
  <li>Issue the command <b>./download Structures</b> to download the code example into your project directory's <b>app</b> directory.</li>
</ul>

<p>Alternatively, you can click the link to the tarball below:</p>

<ul>
  <li><a href="Structures.tar.gz">Structures.tar.gz</a></li>
</ul>

</div>

</body>
</html>
Mis_redirected¢DtypeEvalueõIhttp_code¢DtypeEvalueÈQdownload_complete¢DtypeEvalueõ