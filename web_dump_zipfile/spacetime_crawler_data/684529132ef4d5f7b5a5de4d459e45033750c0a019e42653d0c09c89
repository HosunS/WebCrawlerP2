¦Ifinal_url¡DtypeLhttp_headers¢DtypeEvalue‡¢Ak¢DtypeEvalueNContent-LengthAv¢DtypeEvalueD2133¢Ak¢DtypeEvalueMAccept-RangesAv¢DtypeEvalueEbytes¢Ak¢DtypeEvalueFServerAv¢DtypeEvalueXjApache/2.4.6 (CentOS) OpenSSL/1.0.2k-fips SVN/1.7.14 Phusion_Passenger/4.0.53 mod_perl/2.0.10 Perl/v5.16.3¢Ak¢DtypeEvalueMLast-ModifiedAv¢DtypeEvalueXWed, 17 Apr 2013 01:54:17 GMT¢Ak¢DtypeEvalueDETagAv¢DtypeEvalueS"855-4da84c37b0440"¢Ak¢DtypeEvalueDDateAv¢DtypeEvalueXThu, 31 Jan 2019 11:55:40 GMT¢Ak¢DtypeEvalueLContent-TypeAv¢DtypeEvalueXtext/plain; charset=UTF-8Kraw_content¢DtypeEvalueYU/*
    $Id: output.h 1109 2007-04-17 00:04:26Z rvernica $

    Copyright (C) 2007 by The Regents of the University of California

    Redistribution of this file is permitted under the terms of the
    GNU Public License (GPL).

    Date: 01/30/2007
    Author: Rares Vernica <rvernica@ics.uci.edu>
*/

#ifndef _output_h_
#define _output_h_

#include <ostream>
#include <map>
#include <set>
#include <string>
#include <utility>
#include <vector>
#include <tr1/unordered_map>
#include <tr1/unordered_set>

using namespace std;
using namespace tr1;

template <class T>
ostream& operator<<(ostream& out, const vector<T> &v) 
{
  out << '[';
  for(typename vector<T>::const_iterator it = v.begin(); it != v.end(); it++) {
    if (it != v.begin()) {
      out << ", ";
    }
    out << *it;
  }
  out << ']';

  return out;
}

template <class T>
ostream& operator<<(ostream& out, const set<T> &v) 
{
  out << '(';
  for(typename set<T>::const_iterator it = v.begin(); it != v.end(); it++) {
    if (it != v.begin()) {
      out << ", ";
    }
    out << *it;
  }
  out << ')';

  return out;
}


template <class T>
ostream& operator<<(ostream& out, const unordered_set<T> &v) 
{
  out << '(';
  for(typename unordered_set<T>::const_iterator it = v.begin();
      it != v.end(); it++) {
    if (it != v.begin()) {
      out << ", ";
    }
    out << *it;
  }
  out << ')';

  return out;
}

template <class T, class V>
ostream& operator<<(ostream& out, const map<T, V> &v) 
{
  out << '(';
  for(typename map<T, V>::const_iterator it = v.begin(); it != v.end(); it++) {
    if (it != v.begin()) {
      out << ", ";
    }
    out << *it;
  }
  out << ')';

  return out;
}

template <class T, class V>
ostream& operator<<(ostream& out, const unordered_map<T, V> &v) 
{
  out << '(';
  for(typename unordered_map<T, V>::const_iterator it = v.begin();
      it != v.end(); it++) {
    if (it != v.begin()) {
      out << ", ";
    }
    out << *it;
  }
  out << ')';

  return out;
}


template <class T, class V>
ostream& operator<<(ostream& out, const pair<T, V> &p) 
{
  return out << '(' << p.first << ',' << p.second << ')';
}

#endif

Mis_redirected¢DtypeEvalueôIhttp_code¢DtypeEvalueÈQdownload_complete¢DtypeEvalueõ