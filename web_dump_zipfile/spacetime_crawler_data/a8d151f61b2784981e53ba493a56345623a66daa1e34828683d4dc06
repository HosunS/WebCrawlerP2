¦Ifinal_url¢DtypeEvaluex7https://www.ics.uci.edu/~thornton/ics45c/Notes/Strings/Lhttp_headers¢DtypeEvalue‡¢Ak¢DtypeEvalueNContent-LengthAv¢DtypeEvalueE10248¢Ak¢DtypeEvalueMAccept-RangesAv¢DtypeEvalueEbytes¢Ak¢DtypeEvalueFServerAv¢DtypeEvalueX4Apache/2.4.6 (CentOS) OpenSSL/1.0.2k-fips SVN/1.7.14¢Ak¢DtypeEvalueMLast-ModifiedAv¢DtypeEvalueXMon, 07 Jan 2019 04:44:33 GMT¢Ak¢DtypeEvalueDETagAv¢DtypeEvalueT"2808-57ed6e293ee40"¢Ak¢DtypeEvalueDDateAv¢DtypeEvalueXWed, 30 Jan 2019 20:06:51 GMT¢Ak¢DtypeEvalueLContent-TypeAv¢DtypeEvalueXtext/html; charset=UTF-8Kraw_content¢DtypeEvalueY(<?xml version="1.0" encoding="iso-8859-1"?>
<!DOCTYPE html PUBLIC
 "-//W3C//DTD XHTML 1.1//EN"
 "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">

<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en">

<head>
<meta http-equiv="content-type" content="text/html; charset=iso-8859-1" />
<link rel="stylesheet" href="../../course.css" type="text/css" />

<title>ICS 45C Winter 2019, Notes and Examples: Strings</title>

</head>

<body>

<div class="navbar">

<p>
ICS 45C Winter 2019 |
<a href="../../index.html">News</a> |
<a href="../../CourseReference.html">Course Reference</a> |
<a href="../../Schedule.html">Schedule</a> |
<a href="../../ProjectGuide">Project Guide</a> |
<a href="../../Notes">Notes and Examples</a> |
<a href="http://www.ics.uci.edu/~thornton/">About Alex</a>
</p>

<hr />

</div>

<div class="header">

<p>ICS 45C Winter 2019<br />
   Notes and Examples: Strings</p>

</div>

<div class="section">

<hr />

<p class="title">The <i>std::string</i> type</p>

<p>Like almost every programming language, C++ provides a string data type, which implements the notion of a sequence of text characters.  As it turns out, C++ does not have a built-in string type; its string type is part of its standard library.  Like most types in its standard library, the type is part of the <b>std</b> namespace, so its full name is <b>std::string</b>.</p>

<p>The <b>std::string</b> type plays roughly the same role in C++ that string types in most programming languages play.  As you might imagine, strings are actually more complex than they seem at first glance &mdash; memory has to be managed properly, and the notion of "What is a character?" is trickier in practice than you might think &mdash; so it's handy to have a type that shields you from these details automatically.  (It should be pointed out, though, that <b>std::string</b> provides no support for Unicode encodings like UTF-8; that limitation won't cause us any trouble in this course, but it's worth understanding that strings are complicated beasts, especially if you want to write software that supports internationalized text.)</p>

<p>A <b>std::string</b> object represents a sequence of characters (i.e., a sequence of <b>char</b> objects).  It provides a combination of operators and member functions that implement the basic operations you'll likely want to use given one or more <b>std::string</b>s.  A few examples follow:</p>

<blockquote><pre>
#include &lt;iostream&gt;
#include &lt;string&gt;

...

std::string s = "Alex";
s += " Thornton";    // += appends characters to an existing string


std::string s2 = "Alex Thornton";

if (s == s2)      // == compares strings for equality, i.e., the same sequence of characters
{
    std::cout &lt;&lt; "Yep!" &lt;&lt; std::endl;
}
else
{
    std::cout &lt;&lt; "Nope!" &lt;&lt; std::endl;
}


// The length() member function returns the number of characters in the string.
// There is also a member function called size() that does the same thing.
for (unsigned int i = 0; i < s.length(); i++)
{
    // The [] notation here asks for one character in the string.  Indexing is
    // zero-based, so <b>s[0]</b> would be the first character, <b>s[1]</b> would
    // be the second, and so on.
    std::cout &lt;&lt; s[i] &lt;&lt; std::endl;
}
</pre></blockquote>

</div>

<div class="section">

<hr />

<p class="title">Contrasting the C++ std::string type with strings in Python and Java</p>

<p>Both Python and Java also provide a built-in string type.  While they're similar to their counterpart in C++, they differ in a few important ways.  Since a lot of you know Python or Java already, it's not a bad idea to contrast the C++ <b>std::string</b> type with the string type(s) you might already know.</p>

<p class="subtitle">Immutability</p>

<p>In both Python and Java, string objects are <i>immutable</i>, which means that they cannot be changed once they're created.  At first glance, that might seem strange, because you might have written something like this before in a Python interpreter:</p>

<blockquote><pre>
&gt;&gt;&gt; s = 'Alex'
&gt;&gt;&gt; s += ' Thornton'
&gt;&gt;&gt; s
'Alex Thornton'
</pre></blockquote>

<p>Given that example, it certainly looks like <b>s</b> can be changed, and that the <b>+=</b> operator is one way to do it.  However, it's important to understand what's really happening there.  The use of <b>+=</b> in Python creates a <i>new</i> string object, copies the characters from the old one, then appends the new characters to it, then makes <b>s</b> refer to the new string.  (The variable <b>s</b> isn't a string at all; it's a <i>reference</i> to a string.)  Afterward, the old string is destroyed automatically via garbage collection in this case, since we can no longer refer to it.</p>

<p>All of this is true in Java, as well, with one additional caveat, demonstrated below:</p>

<blockquote><pre>
String s = "Alex";
String s2 = s + " Thornton";
String s3 = "Alex Thornton";

if (s2 == s3)
{
    System.out.println("Yep!");
}
else
{
    System.out.println("Nope!");
}
</pre></blockquote>

<p>In Java, <b>s</b>, <b>s2</b>, and <b>s3</b> are what are called <i>references</i>.  The <b>==</b> operator explicitly compares two references to see whether they refer to the same object; it tests for object <i>identity</i>, not object <i>equality</i>.  In this case, <b>s2</b> and <b>s3</b> will actually be referring to different string objects, albeit objects that have the same meaning (i.e., the same sequence of characters in them).  Alas, the output here will be <b>Nope!</b>, because <b>s2</b> and <b>s3</b> don't refer to the same object.  The workaround would be to write <b>s2.equals(s3)</b> instead, which is how you test for object equivalence in Java; however, this is an easy mistake to make, one that compiles and runs while giving sporadically incorrect output.</p>

<p>By way of contrast, a <b>std::string</b> variable in C++ is not a reference, a pointer, or anything else; it's actually a string.  Updating it actually updates the string.  Behind the scenes, there is some memory management going on, which we'll see, but the effect here is that <b>std::string</b> objects in C++ are <i>mutable</i> (i.e., their sequence of characters can be changed throughout their lifetimes).</p>

<p class="subtitle">Bounds checking</p>

<p>In both Python and Java, if you attempt to access parts of a string that aren't there, such as individual characters or substrings, the attempt will fail with an exception.  This means it will be impossible to accidentally access memory that isn't part of the string, which eliminates a whole class of problems that might arise from mistakes you might make.  Though these errors will generally be run-time errors, it's nonetheless valuable that they're errors.</p>

<p>In C++, things are different.  Performance is considered a premium, and features that affect performance are generally provided only via an <i>opt-in</i> mechanism (i.e., you have to decide to do things that have cost, rather than having them done for you).  As a result, <i>bounds checking</i> is not done by default on strings &mdash; or, as a general rule, any of the data structures that are part of the language and library &mdash; so attempts to access parts of a string that aren't there result in what is called "undefined behavior," meaning that there is no guarantee what will happen, but the program will not necessarily crash and, even if it does, will not crash in a meaningful, easily-debuggable way (e.g., an exception with a traceback, like you might see in Python).  For example, this code in C++ results in undefined behavior:</p>

<blockquote><pre>
std::string s = "Alex";
std::cout &lt;&lt; s[5] &lt;&lt; std::endl;   // There is no index 5!
s[5] = 'b';                       // Oh no!  Where will the 'b' get stored?
</pre></blockquote>

<p>Depending on your compiler, your operating system, and your C++ standard library, this code might crash or it might simply misbehave &mdash; by grabbing the character in the memory beyond the end of the string <b>s</b> and printing it (or changing it!), even though it's not part of the string.</p>

<p>This is a dangerous default, but it is the reality in C++; the onus is on us to opt into bounds checking when we can afford it from a performance perspective.  One way to do that with C++ <b>std::string</b>s is to use the member function <b>at()</b> instead of the <b>[ ]</b> (indexing) operator:</p>

<blockquote><pre>
std::string s = "Alex";
std::cout &lt;&lt; s.at(5) &lt;&lt; std::endl;
s.at(5) = 'b';
</pre></blockquote>

<p>The primary difference between <b>at()</b> and the <b>[ ]</b> operator is bounds checking: <b>at()</b> checks whether the index you pass to it is legitimate (i.e., within the bounds of the string) and, if not, <i>throws an exception</i>.  We'll talk about exceptions in more detail toward the end of the quarter, though there are a fair number of things we need to get under our belts first in order to use them effectively, so we'll postpone that conversation for now.</p>

</div>

<div class="section">

<hr />

<p class="title">C-style strings</p>

<p>If you've ever programmed in C, you may have also seen another, more primitive form of string, implemented as a pointer to an array of characters, commonly written with the type <b>char*</b>.  (We'll learn more about pointers and arrays soon.)  C actually doesn't provide a string type in its library; instead, strings are implemented as pointers to arrays of characters, with various library functions used to manage these arrays and pointers.  As you might imagine, this kind of thing turns out to be quite error-prone, and the kinds of issues that occur when you make a mistake can be difficult to find and fix (and can sometimes be dangerous, from a security perspective).</p>

<p>We'll generally avoid C-style strings in this course altogether.  Because some parts of the C++ Standard Library do make use of them, we may occasionally need them, but whenever we can avoid using C-style strings, we certainly will.</p>

</div>

</body>
</html>
Mis_redirected¢DtypeEvalueõIhttp_code¢DtypeEvalueÈQdownload_complete¢DtypeEvalueõ