¶Ifinal_url°DtypeLhttp_headers¢DtypeEvalueá¢Ak¢DtypeEvalueNContent-LengthAv¢DtypeEvalueD1693¢Ak¢DtypeEvalueMAccept-RangesAv¢DtypeEvalueEbytes¢Ak¢DtypeEvalueFServerAv¢DtypeEvalueXÑApache/2.4.6 (CentOS) OpenSSL/1.0.2k-fips SVN/1.7.14 mod_wsgi/3.4 Python/2.7.5 Phusion_Passenger/4.0.53 mod_perl/2.0.10 Perl/v5.16.3¢Ak¢DtypeEvalueMLast-ModifiedAv¢DtypeEvalueXWed, 17 Apr 2013 01:53:13 GMT¢Ak¢DtypeEvalueDETagAv¢DtypeEvalueS"69d-4da84bfaa7440"¢Ak¢DtypeEvalueDDateAv¢DtypeEvalueXFri, 08 Feb 2019 07:24:50 GMT¢Ak¢DtypeEvalueLContent-TypeAv¢DtypeEvalueXtext/plain; charset=UTF-8Kraw_content¢DtypeEvalueYù/*
  $Id$

  Copyright (C) 2007 by The Regents of the University of California

  Redistribution of this file is permitted under the terms of the 
  BSD license

  Date: 01/14/2006
  Author: Rares Vernica <rares (at) ics.uci.edu>
*/

#include "lexic.h"

class LexicCmp
{
private:
  const vector<string> *data;
public:
  LexicCmp(const vector<string> *d): data(d) {}
  bool operator()(unsigned a, unsigned b) const { return (*data)[a] < (*data)[b]; }
};  

Lexic::Lexic(const vector<string> *d, const unsigned clusterNo, 
             const SampleType sampleType, const unsigned samplePer,
             const unsigned queueSize, const unsigned uniqueNo): 
  Clusters(d, clusterNo, sampleType, samplePer, queueSize, uniqueNo)
{  
  for (unsigned i = 0; i < clusterNo; i++)
    clusters->push_back(Cluster());
}

void Lexic::buildClusters() 
{
  vector<unsigned> dId(data->size());
  for (unsigned i = 0; i < data->size(); i++) dId[i] = i;

  sort(dId.begin(), dId.end(), LexicCmp(data));

  const unsigned n = static_cast<unsigned>(data->size());
  const unsigned nclust = n/clusterNo;
  for (unsigned i = 0; i < clusterNo; i++) {
    const unsigned start = i*nclust;
    const unsigned end = (i == clusterNo? n:(i + 1) * nclust);
    const unsigned p = start + (end - start)/2;
    (*clusters)[i].setPivot(dId[p]);
    SimType radius = (*clusters)[i].getRadius();
    for (unsigned j = start; j < end; j++) {
      (*clusters)[i].insert(dId[j]);
      radius = max(radius, SimDist((*data)[dId[p]], (*data)[dId[j]]));
    }
    (*clusters)[i].setRadius(radius);
  }
}

ostream& Lexic::info(ostream& out)
{
  Clusters::info(out);
  out << "Cluster method\tLexic" << endl;
  return out << endl;
}
Mis_redirected¢DtypeEvalueÙIhttp_code¢DtypeEvalue»Qdownload_complete¢DtypeEvalueı